
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Music@8481 Premium</title>
    
    <!-- PWA & Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f1014">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.ibb.co/zhg1w3dw/file-00000000aca472308a4675a6979753cb.png">
    <link rel="icon" type="image/png" href="https://i.ibb.co/zhg1w3dw/file-00000000aca472308a4675a6979753cb.png">

    <!-- Fonts & Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
        	    --dominant-rgb: 30, 30, 30;
            --primary: #1db954;
            --dark: #0f1014;
            --light-dark: #1e222b;
            --text: #ffffff;
            --text-sec: #aeb6c4;
            --nav-height: 70px;
            --mini-player-height: 70px;
            --accent: #1ed760;
            --dot-blue: #00ccff;
            --bg-grad: linear-gradient(135deg, #1c1c1c, #1a237e, #004d40, #880e4f, #000000);
            --lyric-passed: #ff66b2; 
            --lyric-active: #1db954; 
            --lyric-future: #ffffff; 
        }

        /* --- BROWSER BLOCKING & BASE STYLES --- */
        * { 
            margin: 0; padding: 0; box-sizing: border-box; 
            font-family: 'Inter', sans-serif; 
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        
        img { 
            -webkit-user-drag: none; 
            -khtml-user-drag: none; 
            -moz-user-drag: none; 
            -o-user-drag: none; 
            pointer-events: none;
        }

        body { 
            background-color: var(--dark); 
            color: var(--text); 
            overflow: hidden; 
            height: 100vh; height: 100dvh; 
            display: flex; flex-direction: column; 
            touch-action: pan-y;
        }

        ::-webkit-scrollbar { width: 0px; background: transparent; }
        .hidden { display: none !important; }
        .flex { display: flex; }
        .center { align-items: center; justify-content: center; }
        .loader { width: 30px; height: 30px; border: 3px solid var(--light-dark); border-top: 3px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .text-green { color: var(--primary) !important; }

        #app { flex: 1; overflow-y: auto; padding-bottom: calc(var(--nav-height) + var(--mini-player-height) + 20px); position: relative; scroll-behavior: smooth; }

        header { padding: 15px 20px; position: sticky; top: 0; background: rgba(15,16,20,0.95); backdrop-filter: blur(10px); z-index: 100; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .logo-img { height: 45px; object-fit: contain; display: block; pointer-events: none; } 
        .lang-tag { font-size: 10px; background: var(--light-dark); padding: 5px 10px; border-radius: 20px; color: var(--accent); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; border: 1px solid #333; }
        
        .dj-btn { transition: all 0.3s ease; font-size: 18px; cursor: pointer; color: white; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; border-radius: 50%; background: rgba(255,255,255,0.1); pointer-events: auto; }
        .dj-btn.mode-bass { color: #ff4500 !important; box-shadow: 0 0 15px #ff4500; background: rgba(255, 69, 0, 0.2); animation: pulseRed 1s infinite; }
        .dj-btn.mode-enhanced { color: #00f2ff !important; box-shadow: 0 0 15px #00f2ff; background: rgba(0, 242, 255, 0.2); animation: pulseCyan 1s infinite; }
        .dj-btn.mode-8d { color: #d500f9 !important; box-shadow: 0 0 15px #d500f9; background: rgba(213, 0, 249, 0.2); animation: pulsePurple 1s infinite; }
        
        @keyframes pulseRed { 0% { box-shadow: 0 0 0 0 rgba(255, 69, 0, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 69, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 69, 0, 0); } }
        @keyframes pulseCyan { 0% { box-shadow: 0 0 0 0 rgba(0, 242, 255, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(0, 242, 255, 0); } 100% { box-shadow: 0 0 0 0 rgba(0, 242, 255, 0); } }
        @keyframes pulsePurple { 0% { box-shadow: 0 0 0 0 rgba(213, 0, 249, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(213, 0, 249, 0); } 100% { box-shadow: 0 0 0 0 rgba(213, 0, 249, 0); } }

        .section-title { padding: 0 20px; margin: 25px 0 15px; font-size: 18px; font-weight: 700; }
        
        .grid-scroll { display: flex; overflow-x: auto; gap: 15px; padding: 0 20px 10px; scroll-snap-type: x mandatory; }
        .grid-scroll-multi { display: grid; grid-template-rows: repeat(2, auto); grid-auto-flow: column; overflow-x: auto; gap: 15px; padding: 0 20px 10px; scroll-snap-type: x mandatory; }
        
        .card { min-width: 140px; max-width: 140px; scroll-snap-align: start; cursor: pointer; position: relative; pointer-events: auto; }
        .card:active img { transform: scale(0.95); opacity: 0.8; }
        .card img { width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 8px; margin-bottom: 8px; transition: transform 0.2s; background: #222; pointer-events: none; }
        .card h3 { font-size: 13px; color: var(--text); font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card .marquee-content { overflow: visible !important; text-overflow: clip !important; }
        
        .card p { font-size: 11px; color: var(--text-sec); text-transform: capitalize; }
        .card.circle-img { min-width: 110px; max-width: 110px; text-align: center; }
        .card.circle-img img { border-radius: 50%; width: 100px; height: 100px; }
        
        .dev-footer { text-align: center; padding: 30px 20px 10px; color: #666; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; width: 100%; }

        .marquee-container { overflow: hidden; position: relative; width: 100%; display: flex; justify-content: flex-start; mask-image: linear-gradient(90deg, transparent 0%, black 5%, black 95%, transparent 100%); -webkit-mask-image: linear-gradient(90deg, transparent 0%, black 5%, black 95%, transparent 100%); pointer-events: none; }
        .marquee-content { display: inline-block; white-space: nowrap; padding-right: 20px; will-change: transform; }
        .animate-pingpong { animation: pingPongAnim var(--duration) linear infinite alternate; }
        @keyframes pingPongAnim { 0%, 20% { transform: translateX(0); } 80%, 100% { transform: translateX(calc(-100% + var(--container-width))); } }
        .animate-scroll { animation: scrollOneWay var(--duration) linear infinite; }
        @keyframes scrollOneWay { 0%, 20% { transform: translateX(0); } 80%, 100% { transform: translateX(var(--scroll-dist)); } }

        .list-view { padding: 0 20px; }
        .list-item { display: flex; align-items: center; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; user-select: none; -webkit-user-select: none; pointer-events: auto; position: relative; }
        .list-item:active { background: rgba(255,255,255,0.05); }
        .list-item img { width: 50px; height: 50px; border-radius: 4px; object-fit: cover; margin-right: 15px; background: #222; flex-shrink: 0; pointer-events: none; }
        .list-item.artist-item img { border-radius: 50%; }
        .list-info { flex: 1; overflow: hidden; min-width: 0; }
        .list-info h4 { font-size: 14px; font-weight: 500; margin-bottom: 2px; }
        .list-info p { font-size: 12px; color: var(--text-sec); }

        #search-container { padding: 15px 20px; background: var(--dark); position: sticky; top: 0; z-index: 50; }
        #search-input { width: 100%; padding: 12px 40px 12px 15px; border-radius: 8px; border: none; background: #222; color: white; font-size: 15px; outline: none; pointer-events: auto; }
        .search-icon-inside { position: absolute; right: 35px; top: 50%; transform: translateY(-50%); color: #666; }
        .search-header { font-size: 16px; font-weight: 800; color: white; margin: 25px 0 10px; padding-left: 10px; border-left: 4px solid var(--accent); letter-spacing: 0.5px; text-transform: uppercase; }

        .setting-group { padding: 20px; }
        .setting-label { font-size: 13px; color: var(--text-sec); margin-bottom: 12px; display: block; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .chip-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 30px; }
        .chip-btn { padding: 10px 5px; background: #1e222b; border: 1px solid #333; border-radius: 8px; color: #ccc; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; transition: all 0.2s; pointer-events: auto; }
        .chip-btn.active { background: var(--primary); color: white; border-color: var(--primary); box-shadow: 0 4px 10px rgba(29, 185, 84, 0.3); }
        .quality-row { display: flex; background: #1e222b; border-radius: 10px; padding: 4px; border: 1px solid #333; margin-bottom: 30px; }
        .quality-btn { flex: 1; padding: 10px 0; text-align: center; font-size: 11px; font-weight: 700; color: #888; border-radius: 8px; cursor: pointer; transition: all 0.2s; pointer-events: auto; }
        .quality-btn.active { background: #333; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; background: #1e222b; padding: 15px; border-radius: 12px; border: 1px solid #333; }
        .toggle-text { font-size: 14px; font-weight: 600; color: white; }
        .switch { position: relative; display: inline-block; width: 50px; height: 26px; pointer-events: auto; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(24px); }
        .reset-btn { width: 100%; background: #e91429; border: none; color: white; padding: 15px; border-radius: 12px; font-weight: 700; font-size: 14px; box-shadow: 0 5px 15px rgba(233, 20, 41, 0.3); cursor: pointer; pointer-events: auto; }
        
        /* New Library UI Styles */
        .lib-header { padding: 40px 20px 15px; display: flex; justify-content: space-between; align-items: flex-end; }
        .lib-title { font-size: 26px; font-weight: 800; display: flex; align-items: center; gap: 10px; }
        .lib-profile-icon { width: 35px; height: 35px; background: var(--primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: black; font-size: 14px; }
        .lib-search-box { position: absolute; left: 20px; right: 20px; top: 90px; background: #222; border-radius: 8px; z-index: 10; padding: 10px; border: 1px solid #333; display: none; }
        .lib-search-box.active { display: block; }
        .lib-search-input { width: 100%; background: transparent; border: none; color: white; font-size: 14px; outline: none; }

        .filter-chips { display: flex; gap: 10px; padding: 0 20px 20px; overflow-x: auto; -ms-overflow-style: none; scrollbar-width: none; }
        .filter-chips::-webkit-scrollbar { display: none; }
        .filter-chip { padding: 8px 16px; background: rgba(255,255,255,0.1); border-radius: 20px; font-size: 12px; font-weight: 600; color: white; white-space: nowrap; border: 1px solid transparent; transition: all 0.2s; cursor: pointer; pointer-events: auto; }
        .filter-chip.active { background: var(--primary); color: black; border-color: var(--primary); }
        .lib-grid-view { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; padding: 0 20px 20px; }
        
        .download-badge { position: absolute; top: 5px; right: 5px; background: var(--primary); color: black; font-size: 8px; padding: 2px 5px; border-radius: 4px; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        
        /* Views */
        #album-view { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--dark); z-index: 210; overflow-y: auto; padding-bottom: 150px; transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); }
        #artist-view { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--dark); z-index: 200; overflow-y: auto; padding-bottom: 150px; transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); }
        #album-view.active, #artist-view.active { transform: translateX(0); }
        
        .view-header { padding: 80px 20px 20px; background: linear-gradient(180deg, #333 0%, var(--dark) 100%); display: flex; flex-direction: column; align-items: center; text-align: center; overflow: hidden; }
        
        .art-wrapper { position: relative; margin-bottom: 20px; width: 180px; height: 180px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .art-wrapper.round { border-radius: 50%; width: 160px; height: 160px; }
        .art-wrapper img.main-art { width: 100%; height: 100%; border-radius: 8px; object-fit: cover; background: #222; pointer-events: none; }
        .art-wrapper.round img.main-art { border-radius: 50%; }
        .art-wrapper img.watermark { position: absolute; top: 6px; left: 6px; width: 30px; height: 30px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.5); box-shadow: 0 0 10px rgba(255, 20, 147, 0.9); z-index: 10; object-fit: cover; background: black; display: none; pointer-events: none; }
        .art-wrapper img.watermark.show { display: block; }

        .view-header h2 { font-size: 20px; font-weight: 700; margin-bottom: 5px; line-height: 1.2; width: 100%; }
        
        .view-header p { 
            font-size: 14px; 
            color: var(--text-sec); 
            margin-bottom: 5px; 
            width: 100%;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal; 
            line-height: 1.4;
        }
        
        .view-header .meta-info { font-size: 12px; color: #aaa; margin-bottom: 15px; font-weight: 500; display: block; width: 100%; }
        
        .view-actions { display: flex; gap: 15px; margin-top: 10px; }
        .btn-action { padding: 10px 25px; border-radius: 30px; border: none; font-weight: 700; font-size: 12px; cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 8px; pointer-events: auto; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.1); }
        .back-btn { position: absolute; top: 20px; left: 20px; width: 40px; height: 40px; background: rgba(0,0,0,0.5); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; font-size: 18px; color: white; pointer-events: auto; }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 20000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-box { background: #1e222b; padding: 25px; border-radius: 16px; width: 85%; max-width: 320px; text-align: center; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 40px rgba(0,0,0,0.5); transform: scale(0.9); transition: transform 0.2s; }
        .modal-overlay.active { display: flex; }
        .modal-overlay.active .modal-box { transform: scale(1); }
        .modal-title { font-size: 18px; font-weight: 700; margin-bottom: 10px; color: white; }
        .modal-desc { font-size: 14px; color: #aeb6c4; margin-bottom: 25px; line-height: 1.4; }
        .modal-btns { display: flex; gap: 15px; justify-content: center; }
        .modal-btn { padding: 12px 0; border-radius: 25px; font-size: 14px; font-weight: 700; border: none; cursor: pointer; flex: 1; transition: opacity 0.2s; pointer-events: auto; }
        .modal-btn:active { opacity: 0.8; }
        .btn-cancel { background: rgba(255,255,255,0.1); color: white; }
        .btn-confirm { background: #e91429; color: white; }

        @keyframes premiumFlow { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes spinVinyl { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #mini-player { 
            position: fixed; bottom: calc(var(--nav-height) + 15px); left: 15px; width: calc(100% - 30px); height: 65px; 
            background: var(--bg-grad); background-size: 300% 300%; animation: premiumFlow 12s ease infinite;
            border-radius: 12px; display: none; align-items: center; padding: 0 12px; z-index: 3000; 
            transform: translateY(200%); opacity: 0; box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.05); touch-action: none;
        }
        .mp-smooth { transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease; }
        
        .mp-progress-bg { position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background: rgba(255,255,255,0.1); }
        .mp-progress-fill { height: 100%; background: var(--accent); width: 0%; border-radius: 2px; transition: width 0.1s linear; }
        .mp-img-wrap { width: 45px; height: 45px; margin-right: 12px; position: relative; flex-shrink: 0; }
        .mp-img { width: 100%; height: 100%; border-radius: 6px; object-fit: cover; background: #333; position: relative; z-index: 2; box-shadow: 0 4px 8px rgba(0,0,0,0.3); pointer-events: none; }
        .mp-img.spin-anim { border-radius: 50%; animation: spinVinyl 6s linear infinite; } 
        .mp-info { flex: 1; overflow: hidden; padding-right: 5px; min-width: 0; z-index: 2; display: flex; flex-direction: column; justify-content: center; }
        .mp-title { font-size: 14px; font-weight: 700; color: white; margin-bottom: 2px; }
        .mp-artist-mini { font-size: 11px; color: rgba(255,255,255,0.7); }
        .mp-controls { display: flex; align-items: center; gap: 5px; z-index: 2; }
        .mp-ctrl { background: none; border: none; color: white; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px; transition: color 0.2s; pointer-events: auto; }
        .mp-play-btn { color: white; font-size: 20px; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border-radius: 50%; margin: 0 5px; }
        .mp-heart { font-size: 18px; color: rgba(255,255,255,0.5); width: 35px; height: 35px; display:flex; align-items:center; justify-content:center; cursor:pointer; pointer-events: auto; }
        .mp-heart.liked { color: #e91429; }

        #full-player { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 12000;
            padding: 25px; display: flex; flex-direction: column; justify-content: space-evenly; 
            transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); 
        }
        #full-player.active { transform: translateY(0); }
        
        #fp-bg-gradient { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    background: linear-gradient(180deg, rgba(var(--dominant-rgb), 0.8) 0%, rgba(var(--dominant-rgb), 0.35) 40%, var(--dark) 80%, var(--dark) 100%);
    z-index: -2; 
    transition: background 1.2s cubic-bezier(0.25, 1, 0.5, 1), opacity 1s ease; 
}
        
        #full-player.canvas-immersive { justify-content: flex-end; padding-bottom: calc(env(safe-area-inset-bottom) + 30px); }
        #full-player.canvas-immersive .fp-top, #full-player.canvas-immersive .fp-info, #full-player.canvas-immersive .fp-controls, #full-player.canvas-immersive .slider-container, #full-player.canvas-immersive #mini-lyrics-player { display: none !important; }
        #full-player.canvas-immersive .fp-img-container { opacity: 0; pointer-events: none; }

        #immersive-overlay { position: absolute; bottom: 40px; left: 0; width: 100%; padding: 0 25px; display: none; flex-direction: column; gap: 15px; z-index: 20; pointer-events: none; }
        #full-player.canvas-immersive #immersive-overlay { display: flex; animation: fadeUp 0.4s ease; }
        #immersive-lyric { font-size: 24px; font-weight: 800; color: white; text-shadow: 0 2px 10px rgba(0,0,0,0.8); text-align: left; min-height: 30px; line-height: 1.3; }
        .imm-progress-container { width: 100%; }
        .imm-progress-bg { width: 100%; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden; backdrop-filter: blur(5px); }
        .imm-progress-fill { height: 100%; background: #1db954; width: 0%; box-shadow: 0 0 10px rgba(29, 185, 84, 0.5); transition: width 0.1s linear; }
        .imm-time-row { display: flex; justify-content: space-between; font-size: 12px; font-weight: 700; color: rgba(255,255,255,0.8); margin-top: 8px; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }

        .fp-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-shrink: 0; color: white; }
        .fp-img-container { width: 100%; height: 45vh; max-height: 400px; margin: 10px 0; position: relative; display: flex; justify-content: center; align-items: center; perspective: 1000px; overflow: visible; transition: opacity 0.5s ease; }
        .fp-img { position: absolute; width: auto; height: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 12px; box-shadow: 0 15px 40px rgba(0,0,0,0.5); will-change: transform, opacity; transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.4s ease; pointer-events: none; }
        .fp-img.active { transform: translateX(0) scale(1) rotate(0deg); opacity: 1; z-index: 2; }
        
        .fp-info { margin-bottom: 20px; overflow: hidden; width: 100%; flex-shrink: 0; position: relative; }
        .fp-title { font-size: 24px; font-weight: 800; margin-bottom: 5px; line-height: 1.2; display: inline-block; color: white; }
        .fp-artist { color: var(--text-sec); font-size: 16px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
        
        #mini-lyrics-player { margin-top: 15px; width: 100%; padding: 12px 15px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(5px); border-radius: 15px; border: 1px solid rgba(255,255,255,0.1); text-align: center; cursor: pointer; transition: transform 0.2s; display: none; pointer-events: auto; }
        #mini-lyrics-player:active { transform: scale(0.98); }
        .ml-text { font-size: 14px; font-weight: 600; color: white; text-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        /* --- NEW LYRICS BACKGROUND STYLES --- */
        #lyric-bg-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; /* Send behind text */
            overflow: hidden;
        }
        #lyric-bg-img, #lyric-bg-video {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transition: opacity 0.5s ease;
        }
        #lyric-bg-video { opacity: 0; } /* Hidden by default */
        #lyric-bg-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); /* Dark overlay so white text is readable */
            backdrop-filter: blur(8px); /* Blur effect on the background */
            z-index: 1;
        }

        #full-lyrics-view { position: fixed; top: 0; left: 0; width: 100%; height: 100dvh; background: black; z-index: 15000; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1); padding-bottom: env(safe-area-inset-bottom); }
        #full-lyrics-view.active { transform: translateY(0); }
        .flyrics-header { padding: 40px 20px 20px; text-align: center; font-weight: 800; font-size: 16px; letter-spacing: 1px; color: #ccc; }
        .flyrics-scroll { flex: 1; overflow-y: auto; padding: 20px 30px 60px; text-align: left; scroll-behavior: smooth; mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent); -webkit-mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent); }
        .lyric-line { font-size: 24px; font-weight: 700; margin-bottom: 25px; transition: all 0.3s ease; cursor: pointer; pointer-events: auto; }
        .l-past { color: var(--lyric-passed); }
        .l-active { color: var(--lyric-active); transform: scale(1.05); transform-origin: left; text-shadow: 0 0 15px rgba(29, 185, 84, 0.4); }
        .l-future { color: var(--lyric-future); opacity: 0.6; }
        .flyrics-close { position: absolute; top: 40px; right: 20px; width: 40px; height: 40px; border-radius: 50%; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 18px; z-index: 10; pointer-events: auto; }

        .slider-container { width: 90%; margin: 0 auto 15px auto; position: relative; flex-shrink: 0; }
        input[type=range] { -webkit-appearance: none; width: 100%; height: 4px; background-color: rgba(255, 255, 255, 0.1); border-radius: 2px; outline: none; background-image: linear-gradient(var(--accent), var(--accent)); background-repeat: no-repeat; background-size: 0% 100%; pointer-events: auto; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 15px; width: 15px; border-radius: 50%; background: var(--dot-blue); cursor: pointer; box-shadow: 0 0 15px var(--dot-blue), 0 0 3px #ffffff; transition: transform 0.1s; border: 2px solid white; position: relative; z-index: 10; }
        
        .time-wrap { display: flex; justify-content: space-between; font-size: 12px; color: var(--text-sec); margin-top: 8px; }
        .fp-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; margin-bottom: 10px; flex-shrink: 0; }
        .btn-ctrl { background: none; border: none; color: white; font-size: 24px; cursor: pointer; transition: color 0.2s; padding: 10px; display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        .btn-ctrl.active-ctrl { color: var(--accent); } 
        .btn-play-lg { width: 70px; height: 70px; background: white; color: black; border-radius: 50%; font-size: 28px; display: flex; align-items: center; justify-content: center; box-shadow: 0 5px 20px rgba(255, 255, 255, 0.3); pointer-events: auto; }
        .fp-actions { display: flex; gap: 25px; margin-top: 10px; align-items: center; }

        .fp-menu-overlay { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(20, 20, 20, 0.95); backdrop-filter: blur(20px); border-top-left-radius: 20px; border-top-right-radius: 20px; padding: 25px 20px 40px; transform: translateY(100%); transition: transform 0.3s ease; z-index: 13000; border-top: 1px solid rgba(255,255,255,0.1); overflow-y: auto; max-height: 80vh; }
        .fp-menu-overlay.active { transform: translateY(0); }
        .fp-menu-item { display: flex; align-items: center; gap: 15px; padding: 15px 0; border-bottom: 1px solid rgba(255,255,255,0.05); color: white; font-size: 15px; font-weight: 600; cursor: pointer; pointer-events: auto; }
        .fp-menu-item:last-child { border-bottom: none; }
        .fp-menu-item i { width: 25px; text-align: center; font-size: 18px; color: var(--text-sec); }
        .fp-menu-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; color: var(--text-sec); font-size: 12px; font-weight: 700; letter-spacing: 1px; }
        
        .song-details-card { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .detail-row { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; pointer-events: auto; }
        .detail-row:last-child { margin-bottom: 0; }
        .detail-img { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; background: #333; pointer-events: none; }
        .detail-info { flex: 1; }
        .detail-name { font-size: 14px; font-weight: 700; color: white; }
        .detail-sub { font-size: 11px; color: var(--text-sec); }
        .detail-link { background: rgba(255,255,255,0.1); padding: 5px 12px; border-radius: 20px; font-size: 11px; font-weight: 600; color: var(--accent); }
        
        .song-meta-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; background: rgba(255,255,255,0.03); padding: 10px; border-radius: 8px; }
        .meta-item { display: flex; flex-direction: column; }
        .meta-label { font-size: 10px; color: #888; text-transform: uppercase; }
        .meta-val { font-size: 12px; color: #ddd; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        nav { height: var(--nav-height); background: rgba(15,16,20,0.98); border-top: 1px solid #333; display: flex; justify-content: space-around; align-items: center; padding-bottom: env(safe-area-inset-bottom); position: fixed; bottom: 0; left: 0; width: 100%; z-index: 100; }
        .nav-item { display: flex; flex-direction: column; align-items: center; color: #666; font-size: 10px; transition: 0.2s; width: 60px; pointer-events: auto; }
        .nav-item i { font-size: 20px; margin-bottom: 5px; }
        .nav-item.active { color: white; }

        .toast { position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.9); color: black; padding: 10px 20px; border-radius: 20px; font-size: 12px; font-weight: bold; z-index: 15000; display: none; animation: fadeUp 0.3s; pointer-events: none; }
        @keyframes fadeUp { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        
        .card-logo { position: absolute !important; top: 4px !important; left: 4px !important; z-index: 99 !important; width: 25px !important; height: 25px !important; min-width: 25px !important; max-width: 25px !important; min-height: 25px !important; max-height: 25px !important; border-radius: 50% !important; object-fit: cover !important; display: block !important; border: 0.1px solid #fff !important; box-shadow: 0 0 12px rgba(255, 20, 147, 0.9) !important; background-color: #000 !important; pointer-events: none; }

        /* Buffering Overlay */
        .buffering-overlay { position: absolute; left: 0; top: 0; width: 50px; height: 50px; background: rgba(0,0,0,0.5); border-radius: 4px; display: none; align-items: center; justify-content: center; pointer-events: none; z-index: 5; }
        .list-item.artist-item .buffering-overlay { border-radius: 50%; }
        .list-item.buffering .buffering-overlay { display: flex; }
        .buf-spinner { width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.3); border-top: 2px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
        
        /* Card Watermark for Playlists in Library (Corrected Position) */
        .card .watermark-logo { position: absolute !important; top: 4px !important; left: 4px !important; z-index: 99 !important; width: 20px !important; height: 20px !important; border-radius: 50% !important; border: 1px solid rgba(255,255,255,0.8) !important; box-shadow: 0 0 5px rgba(0,0,0,0.8) !important; display: block !important; background: #000 !important; object-fit: cover !important; pointer-events: none; }

        /* YOUTUBE PLAYER STYLES (IMPORTED & ADAPTED) */
        #yt-view-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: black; overflow: hidden; border-radius: 12px; z-index: 20; display: none; 
            /* Ensure it sits over the art but under other overlays if needed */
        }
        #yt-view-container.active { display: block; }
        .video-cover { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 100%; height: 177.77%; pointer-events: none; }
        #wrap, #player, iframe { width: 100%; height: 100%; pointer-events: none; }
        .shield { position: absolute; inset: 0; z-index: 25; }
        .center-unlock { position: absolute; top: 50%; left: 50%; width: 90px; height: 90px; transform: translate(-50%,-50%); border-radius: 50%; pointer-events: auto; }
        .block-area { position: absolute; inset: 0; pointer-events: auto; }
   /* --- NEW PREMIUM YOUTUBE UI --- */
.yt-controls { 
    position: absolute; left: 0; right: 0; bottom: 0; 
    height: 60px; /* Single Line Height */
    background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); 
    z-index: 30; 
    display: flex; align-items: center; gap: 12px; padding: 0 15px;
    opacity: 0; transition: opacity .25s; pointer-events: none; 
}
.yt-controls.show { opacity: 1; pointer-events: auto; }
.yt-controls.hide { opacity: 0; pointer-events: none; }

/* Buttons (Play, Mute, Fullscreen) */
.yt-btn { 
    background: none; border: none; color: white; 
    width: 30px; height: 30px; 
    display: flex; align-items: center; justify-content: center; 
    cursor: pointer; font-size: 16px; 
    transition: transform 0.2s, color 0.2s; pointer-events: auto;
}
.yt-btn:hover { color: #ff2d55; transform: scale(1.1); }

/* Duration Text */
.yt-time { 
    font-size: 11px; font-weight: 700; color: #ddd; 
    white-space: nowrap; font-family: sans-serif; min-width: 70px; text-align: center;
}

/* Progress Bar (Takes remaining space) */
.yt-progress-container { 
    flex: 1; height: 4px; background: rgba(255,255,255,0.2); 
    border-radius: 2px; cursor: pointer; position: relative; 
    transition: height 0.2s; pointer-events: auto; 
}
.yt-progress-container:hover { height: 6px; }

.yt-fill { 
    position: absolute; left: 0; top: 0; height: 100%; width: 0%; 
    background: #ff2d55; /* Premium Red */
    border-radius: 2px; 
}

/* Hover Dot Effect */
.yt-fill::after {
    content: ''; position: absolute; right: -6px; top: 50%; 
    transform: translateY(-50%) scale(0); 
    width: 12px; height: 12px; background: white; border-radius: 50%; 
    box-shadow: 0 0 5px rgba(0,0,0,0.5); transition: transform 0.2s;
}
.yt-progress-container:hover .yt-fill::after { transform: translateY(-50%) scale(1); }

/* 8481 Branding */
.yt-brand { 
    font-size: 14px; font-weight: 900; color: #ff2d55; 
    letter-spacing: 1px; text-shadow: 0 0 10px rgba(255, 45, 85, 0.4); 
    user-select: none; margin-left: 5px; margin-right: 5px;
}
#direct-video-player { width: 100%; height: 100%; object-fit: contain; background: black; position: absolute; top:0; left:0; z-index: 22; display: none; }


/* Add this to your CSS */
#yt-loader {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 25; /* Above video, below controls */
    display: none; /* Hidden by default */
}
#yt-loader .loader {
    width: 40px;
    height: 40px;
    border-width: 4px;
    border-color: rgba(255,255,255,0.3);
    border-top-color: #ff2d55; /* Premium Red */
    margin: 0;
}

/* =========================================
       LANDSCAPE UI IMPLEMENTATION (FINAL STABLE)
       ========================================= */

    /* --- PORTRAIT MODE (DEFAULT - NEMUSIC STYLE) --- */
    /* 1. Hide wrapper containers in Portrait to use simple flex layout */
    .fp-columns, .fp-left-panel, .fp-right-panel { display: contents; }
    .landscape-only { display: none !important; }
    
    /* 2. Center everything in Portrait */
    .fp-info { text-align: center; padding-right: 0; width: 100%; }
    .fp-info .marquee-container { justify-content: center; }
    .fp-title, .fp-artist { text-align: center; }
    .fp-actions { position: relative; right: auto; top: auto; transform: none; justify-content: center; margin-top: 10px; }

    /* --- LANDSCAPE MODE --- */
    @media (orientation: landscape) {
        
        /* 1. FORCE BACKGROUND ANIMATION VISIBILITY */
        #fp-bg-gradient { 
            opacity: 1 !important; 
            z-index: 0 !important; 
            display: block !important; 
        }

        /* 2. STRICTLY HIDE GLOBAL BACKGROUND CANVAS (To prevent overlap) */
        #full-player > #canvas-video { display: none !important; }

        /* 3. STYLE THE MOVED CANVAS (INSIDE FRAME) */
        #fp-img-area #canvas-video {
            display: block !important;
            position: absolute !important;
            top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 12px; object-fit: cover; z-index: 5;
        }
        
        /* 4. STOP ART/CONTAINER FROM VANISHING */
        #fp-img-area { 
            opacity: 1 !important; /* Forces container to stay visible */
            width: 100%; height: auto; flex: 1; max-height: 80%; margin: 0; perspective: none; position: relative; z-index: 10;
        }

        /* 5. LAYOUT RESTORATION */
        .fp-columns { display: flex; flex-direction: row; width: 100%; height: 100%; padding: 20px 50px; gap: 40px; }
        
        /* Left Panel - Holds the Art/Canvas */
        .fp-left-panel { 
            display: flex; width: 40vw !important; max-width: 40vw !important; flex: 0 0 40vw !important; 
            height: 100%; flex-direction: column; justify-content: center; align-items: center; position: relative; 
        }
        
        /* Right Panel - Holds Controls */
        .fp-right-panel { 
            display: flex; width: 60vw !important; max-width: 60vw !important; flex: 0 0 50vw !important; 
            min-width: 0 !important; overflow: hidden !important; height: 100%; flex-direction: column; justify-content: center; 
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); border-radius: 20px; 
            padding: 20px 30px; position: relative; backdrop-filter: blur(10px); z-index: 10;
        }

        .landscape-only { display: flex !important; }
        .fp-top, #mini-lyrics-player { display: none !important; }
        #full-player { padding: 0; flex-direction: row; justify-content: center; align-items: center; }

        /* Header Text moved right */
        .ls-header { position: absolute; top: 0; width: 100%; display: flex; justify-content: flex-start; align-items: center; margin-bottom: 10px; }
        .ls-header-text { 
            font-size: 11px; font-weight: 700; color: #aaa; text-transform: uppercase; letter-spacing: 1px; 
            margin-left: 90px; 
        }
        
        .mode-switcher { display: flex; gap: 5px; background: rgba(255,255,255,0.1); padding: 4px; border-radius: 20px; margin-bottom: 15px; margin-top: 30px; backdrop-filter: blur(10px); z-index: 50; pointer-events: auto; }
        .mode-btn { padding: 6px 14px; border-radius: 16px; font-size: 10px; font-weight: 700; color: #ccc; background: transparent; border: none; cursor: pointer; text-transform: uppercase; transition: all 0.2s; }
        .mode-btn.active { background: var(--primary); color: black; box-shadow: 0 2px 10px rgba(29, 185, 84, 0.4); }

        .fp-img { box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
        
        /* --- ASPECT RATIOS --- */
        .ratio-art #fp-img-area { aspect-ratio: 1/1; }
        /* 9:16 Ratio for Canvas (Shorts Style) */
        .ratio-canvas #fp-img-area { aspect-ratio: 9/16; max-width: 50vh; }
        .ratio-video #fp-img-area { aspect-ratio: 16/9; }

        .ls-menu-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; color: white; font-size: 18px; cursor: pointer; z-index: 10; pointer-events: auto; }

        /* Lyrics Styling - Clickable & Wrapped */
        .ls-lyrics-wrapper { display: flex; align-items: center; gap: 15px; margin-top: 10px; margin-bottom: 20px; height: 85px; overflow: hidden; transition: transform 0.1s; }
        .ls-lyrics-wrapper:active { transform: scale(0.98); opacity: 0.8; }
        .ls-lyrics-text { flex: 1; text-align: left; font-size: 18px; font-weight: 700; color: var(--accent); text-shadow: 0 0 15px rgba(29, 185, 84, 0.3); white-space: normal; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.3; }
        .ls-expand-btn { display: none !important; } 
        
        /* Info Alignments */
        .fp-info { text-align: left; margin-bottom: 10px; padding-right: 50px !important; width: 100%; min-width: 0; position: relative; box-sizing: border-box; }
        .fp-title { font-size: 26px; text-align: left; display: block; }
        .fp-artist { text-align: left; font-size: 16px; display: block; }
        .fp-info .marquee-container { justify-content: flex-start !important; width: 100% !important; max-width: 100% !important; }
        .fp-actions { position: absolute; right: 0; top: 50%; transform: translateY(-50%); margin: 0; z-index: 20; pointer-events: auto; }
        
        .slider-container { width: 100%; margin: 15px 0; }
        .fp-controls { margin-top: 10px; justify-content: space-between; }
        #yt-view-container, #direct-video-player, #canvas-video { border-radius: 12px; }
    }
    </style>
    
    <script>
        const manifest = { "name": "Music@8481", "short_name": "Music@8481", "start_url": ".", "display": "standalone", "background_color": "#0f1014", "theme_color": "#0f1014", "orientation": "portrait", "icons": [{ "src": "https://i.ibb.co/zhg1w3dw/file-00000000aca472308a4675a6979753cb.png", "sizes": "512x512", "type": "image/png" }] };
        const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
        const link = document.createElement('link');
        link.rel = 'manifest';
        link.href = URL.createObjectURL(blob);
        document.head.appendChild(link);
    </script>
</head>
<body>

    <div id="app">
        <!-- Header -->
        <header>
            <div class="flex center">
                <img src="https://i.ibb.co/b5xtqb8V/file-00000000d0e471f88b12a9c223fb5ac3.png" alt="Vibe" class="logo-img">
                <span id="header-lang" class="lang-tag" style="margin-left: 10px;">Hindi</span>
            </div>
            <div class="flex center" style="gap:15px">
                <div class="dj-btn" id="dj-btn" onclick="cycleEqMode()"><i class="fas fa-compact-disc"></i></div>
            </div>
        </header>

        <!-- Home Tab -->
        <div id="home-view">
            <h2 class="section-title">New Releases</h2>
            <div id="new-releases" class="grid-scroll-multi"><div class="loader"></div></div>
            <h2 class="section-title">Featured Playlists</h2>
            <div id="top-playlists" class="grid-scroll-multi"><div class="loader"></div></div>
            <h2 class="section-title">Top Charts</h2>
            <div id="top-charts" class="grid-scroll"><div class="loader"></div></div>
            <div class="dev-footer">Developed by Ayush@8481</div>
        </div>

        <!-- Search Tab -->
        <div id="search-view" class="hidden">
            <div id="search-container">
                <input type="text" id="search-input" placeholder="Search songs, albums, artists...">
                <i class="fas fa-search search-icon-inside"></i>
            </div>
            <div id="search-results" style="padding-bottom: 20px;"></div>
        </div>

        <!-- Library Tab (Redesigned) -->
        <div id="library-view" class="hidden">
            <div class="lib-header">
                <div class="lib-title"><div class="lib-profile-icon">M</div> Your Library</div>
            </div>
            <div class="filter-chips">
                <div class="filter-chip active" onclick="switchLibFilter('all', this)">All</div>
                <div class="filter-chip" onclick="switchLibFilter('albums', this)">Albums</div>
                <div class="filter-chip" onclick="switchLibFilter('playlists', this)">Playlists</div>
                <div class="filter-chip" onclick="switchLibFilter('songs', this)">Songs</div>
            </div>
            <div id="lib-content" style="padding-bottom:100px;"></div>
        </div>

        <!-- Settings Tab -->
        <div id="settings-view" class="hidden">
            <h2 class="section-title">Settings</h2>
            <div class="setting-group">
                <label class="setting-label">Music Language</label>
                <div class="chip-grid" id="lang-grid"></div>
                
                <label class="setting-label">Audio Streaming Quality</label>
                <div class="quality-row" id="quality-row">
                    <div class="quality-btn" onclick="updateQuality('320kbps')">320k</div>
                    <div class="quality-btn" onclick="updateQuality('160kbps')">160k</div>
                    <div class="quality-btn" onclick="updateQuality('96kbps')">96k</div>
                    <div class="quality-btn" onclick="updateQuality('48kbps')">48k</div>
                </div>

                <label class="setting-label">Video Streaming Quality</label>
                <div class="quality-row" id="video-quality-row">
                    <div class="quality-btn" onclick="updateVideoQuality('hd1080')">1080p</div>
                    <div class="quality-btn" onclick="updateVideoQuality('hd720')">720p</div>
                    <div class="quality-btn" onclick="updateVideoQuality('large')">480p</div>
                    <div class="quality-btn" onclick="updateVideoQuality('medium')">360p</div>
                    <div class="quality-btn" onclick="updateVideoQuality('default')">Auto</div>
                </div>

                <label class="setting-label">Preferences</label>
                <div class="toggle-row">
                    <span class="toggle-text">Show Canvas (Video)</span>
                    <label class="switch"><input type="checkbox" id="toggle-canvas" onchange="toggleSetting('canvas')"><span class="slider"></span></label>
                </div>
                <div class="toggle-row">
                    <span class="toggle-text">Show Lyrics</span>
                    <label class="switch"><input type="checkbox" id="toggle-lyrics" onchange="toggleSetting('lyrics')"><span class="slider"></span></label>
                </div>
                <div style="margin-top:20px; text-align:center;">
                    <button class="reset-btn" onclick="localStorage.clear(); window.location.reload();">Reset App Data</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Album View Overlay -->
    <div id="album-view">
        <div class="back-btn" onclick="goBack()"><i class="fas fa-arrow-left"></i></div>
        <div class="view-header">
            <div class="art-wrapper">
                <img id="album-art" class="main-art" src="" alt="">
                <img id="album-watermark" class="watermark" src="https://i.ibb.co/zhg1w3dw/file-00000000aca472308a4675a6979753cb.png" alt="logo">
            </div>
            <div class="marquee-container"><h2 id="album-title" class="marquee-content"></h2></div>
            <p id="album-subtitle"></p> 
            <div class="meta-info" id="album-meta"></div>
            <div class="view-actions">
                <button id="btn-download-album" class="btn-action btn-primary" onclick="downloadPlaylistAction()"><i class="fas fa-download"></i> Download Playlist</button>
                <button id="btn-save-album" class="btn-action btn-secondary" onclick="savePlaylistView()"><i class="fas fa-bookmark"></i> Save</button>
            </div>
        </div>
        <div id="album-tracks" class="list-view"></div>
    </div>

    <!-- Artist View Overlay -->
    <div id="artist-view">
        <div class="back-btn" onclick="goBack()"><i class="fas fa-arrow-left"></i></div>
        <div class="view-header">
            <div class="art-wrapper round">
                <img id="artist-img" class="main-art" src="" alt="">
            </div>
            <div class="marquee-container"><h2 id="artist-name" class="marquee-content"></h2></div>
            <p id="artist-role"></p>
            <div class="meta-info" id="artist-stats"></div>
        </div>
        <div class="section-title">Top Songs</div>
        <div id="artist-songs" class="list-view"></div>
        <div class="section-title">Albums</div>
        <div id="artist-albums" class="grid-scroll" style="padding-bottom:100px;"></div>
    </div>

    <!-- Mini Player -->
    <div id="mini-player" class="mp-smooth">
        <div class="mp-progress-bg"><div class="mp-progress-fill" id="mp-progress"></div></div>
        <div class="mp-img-wrap"><img src="" class="mp-img" id="mini-img"></div>
        <div class="mp-info">
            <div class="marquee-container"><div class="mp-title marquee-content" id="mini-title">Song Title</div></div>
            <div class="marquee-container"><div class="mp-artist-mini marquee-content" id="mini-artist">Artist Name</div></div>
        </div>
        <div class="mp-controls">
            <i class="far fa-heart mp-heart" id="mini-heart" onclick="event.stopPropagation(); toggleLike()"></i>
            <button class="mp-ctrl mp-play-btn" id="mini-play-btn" onclick="event.stopPropagation(); togglePlay()">
                <i class="fas fa-play" id="mini-play-icon"></i>
            </button>
        </div>
    </div>

<!-- Full Player -->
    <div id="full-player">
    
        <video id="canvas-video" muted loop playsinline></video>
        <div id="fp-bg-gradient"></div>
        
        <!-- NEW WRAPPER FOR FLEX LAYOUT -->
        <div class="fp-columns">

            <!-- LEFT PANEL: Visuals & Switcher -->
            <div class="fp-left-panel">
                
                <!-- Landscape Header (Hidden in Portrait) -->
                <div class="ls-header landscape-only">
                    <button class="btn-ctrl" style="width: 40px;" onclick="goBack()"><i class="fas fa-chevron-down"></i></button>
                    <span class="ls-header-text">Now Playing</span>
                </div>

                <!-- Portrait Header (Hidden in Landscape) -->
                <div class="fp-top">
                    <button class="btn-ctrl" style="width: 40px; height: 40px;" onclick="goBack()"><i class="fas fa-chevron-down"></i></button>
                    <div style="font-size: 12px; letter-spacing: 1px; color: #ccc;">NOW PLAYING</div>
                    <button class="btn-ctrl" style="width: 40px; height: 40px;" onclick="toggleFpMenu()"><i class="fas fa-ellipsis-v"></i></button>
                </div>

                <!-- Mode Switcher (Landscape Only) -->
                <div class="mode-switcher landscape-only">
                    <button id="mode-art" class="mode-btn active" onclick="switchVisualMode('art')">Art</button>
                    <button id="mode-can" class="mode-btn" onclick="switchVisualMode('canvas')">Canvas</button>
                    <button id="mode-vid" class="mode-btn" onclick="switchVisualMode('video')">Video</button>
                </div>

                <!-- Visual Container (Shared) -->
                <div class="fp-img-container" id="fp-img-area">
                    <img id="fp-art" class="fp-img active" src="" alt="">
                    <!-- Youtube Video Container -->
                    <div id="yt-view-container">
                        <video id="direct-video-player" playsinline></video>
                        <div id="yt-loader"><div class="loader"></div></div>
                        <div class="video-cover">
                            <div id="wrap"><div id="player"></div></div>
                        </div>
                        <div class="shield">
                            <div class="block-area" id="blockTap"></div>
                            <div class="center-unlock" id="centerTap"></div>
                        </div>
                        <div class="yt-controls hide" id="yt-controls">
                            <button class="yt-btn" id="yt-play-btn" onclick="toggleYtPlay()"><i class="fas fa-play"></i></button>
                            <button class="yt-btn" id="yt-mute-btn" onclick="toggleYtMute()"><i class="fas fa-volume-up"></i></button>
                            <div class="yt-time" id="yt-time">0:00 / 0:00</div>
                            <div class="yt-progress-container" id="yt-bar"><div class="yt-fill" id="yt-fill"></div></div>
                            <div class="yt-brand">8481</div>
                            <button class="yt-btn" onclick="toggleYtFull()"><i class="fas fa-expand"></i></button>
                        </div>
                    </div>
                </div>

                <!-- Immersive Overlay (Shared) -->
                <div id="immersive-overlay">
                    <div id="immersive-lyric"></div>
                    <div class="imm-progress-container">
                        <div class="imm-progress-bg"><div class="imm-progress-fill" id="imm-fill"></div></div>
                        <div class="imm-time-row"><span id="imm-curr">0:00</span><span id="imm-total">0:00</span></div>
                    </div>
                </div>
            </div>

            <!-- RIGHT PANEL: Controls & Info -->
            <div class="fp-right-panel">
                
                <!-- Landscape Menu Button -->
                <button class="ls-menu-btn landscape-only" onclick="toggleFpMenu()"><i class="fas fa-ellipsis-v"></i></button>

      <!-- Landscape Lyrics (New) -->
<div class="ls-lyrics-wrapper landscape-only" onclick="openFullLyrics()" style="cursor: pointer;">
    <div class="ls-lyrics-text" id="ls-lyric-line"></div>
</div>

                <!-- Mini Lyrics (Portrait Only) -->
                <div id="mini-lyrics-player" onclick="openFullLyrics()"><p class="ml-text" id="mini-lyric-text">Lyrics loading...</p></div>

                <!-- Info -->
                <div class="fp-info">
                    <div class="marquee-container"><div class="fp-title marquee-content" id="fp-title">Title</div></div>
                    <div class="marquee-container"><div class="fp-artist marquee-content" id="fp-artist">Artist Name</div></div>
                    <div class="fp-actions"><i class="far fa-heart btn-ctrl" id="fp-heart" onclick="toggleLike()"></i></div>
                </div>

                <!-- Slider -->
                <div class="slider-container">
                    <input type="range" id="seek-slider" min="0" value="0">
                    <div class="time-wrap"><span id="curr-time">0:00</span><span id="total-time">0:00</span></div>
                </div>

                <!-- Controls -->
                <div class="fp-controls">
                    <button class="btn-ctrl" id="btn-shuffle" onclick="toggleShuffle()"><i class="fas fa-random"></i></button>
                    <button class="btn-ctrl" onclick="playPrev()"><i class="fas fa-step-backward"></i></button>
                    <button class="btn-play-lg" onclick="togglePlay()"><i class="fas fa-play" id="fp-play-icon"></i></button>
                    <button class="btn-ctrl" onclick="playNext()"><i class="fas fa-step-forward"></i></button>
                    <button class="btn-ctrl" id="btn-loop" onclick="toggleLoop()"><i class="fas fa-retweet"></i></button>
                </div>

            </div>
        </div>
        
        <!-- Menu Overlay (Shared) -->
        <div class="fp-menu-overlay" id="fp-menu-overlay">
            <div class="fp-menu-header"><span>OPTIONS</span><span onclick="toggleFpMenu()" style="cursor:pointer; padding:5px;">CLOSE</span></div>
            <div id="video-switch-btn"></div>
            <div id="song-details-injection"></div>
            <div id="menu-download-btn" class="fp-menu-item" onclick="downloadCurrentSongAction()"><i class="fas fa-download"></i><span>Download Song</span></div>
            <div class="fp-menu-item">
                <i class="fas fa-sliders-h"></i>
                <div style="flex:1;">
                    <div style="margin-bottom:5px;">Quality</div>
                    <select onchange="changeQualityFromPlayer(this)" onclick="event.stopPropagation()" style="width:100%; padding:8px; margin:0; background:rgba(255,255,255,0.1); border:none; font-size:12px;">
                        <option value="320kbps">Very High (320kbps)</option>
                        <option value="160kbps">High (160kbps)</option>
                        <option value="96kbps">Standard (96kbps)</option>
                        <option value="48kbps">Data Saver (48kbps)</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

<!-- Lyrics Overlay -->
    <div id="full-lyrics-view">
        <!-- START NEW BACKGROUND ELEMENTS -->
        <div id="lyric-bg-container">
            <img id="lyric-bg-img" src="" alt="">
            <video id="lyric-bg-video" muted loop playsinline></video>
            <div id="lyric-bg-overlay"></div>
        </div>
        <!-- END NEW BACKGROUND ELEMENTS -->

        <div class="flyrics-close" onclick="closeFullLyrics()"><i class="fas fa-times"></i></div>
        <div class="flyrics-header">LYRICS</div>
        <div class="flyrics-scroll" id="flyrics-content"></div>
    </div>
    
    <!-- Modal -->
    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-title">Delete?</div>
            <div class="modal-desc">Are you sure you want to delete this from your library?</div>
            <div class="modal-btns">
                <button class="modal-btn btn-cancel" onclick="closeModal()">Cancel</button>
                <button class="modal-btn btn-confirm" id="modal-yes-btn">Delete</button>
            </div>
        </div>
    </div>

    <nav>
        <div class="nav-item active" onclick="switchTab('home')"><i class="fas fa-home"></i><span>Home</span></div>
        <div class="nav-item" onclick="switchTab('search')"><i class="fas fa-search"></i><span>Search</span></div>
        <div class="nav-item" onclick="switchTab('library')"><i class="fas fa-music"></i><span>Library</span></div>
        <div class="nav-item" onclick="switchTab('settings')"><i class="fas fa-cog"></i><span>Settings</span></div>
    </nav>
    <div id="toast" class="toast">Action Completed</div>

<script src="https://www.youtube.com/iframe_api"></script>
<script>
    // Prevent Context Menu (Right Click / Long Press)
    document.oncontextmenu = function(e) {
        if (e.target.tagName === 'IMG' || e.target.tagName === 'A' || e.target.tagName === 'DIV') {
            return false;
        }
    };

    const IdbHelper = {
        dbName: 'Music8481DB', version: 2, db: null,
        init() { 
            return new Promise((resolve, reject) => { 
                const req = indexedDB.open(this.dbName, this.version); 
                req.onupgradeneeded = (e) => { 
                    const db = e.target.result; 
                    if(!db.objectStoreNames.contains('store')) db.createObjectStore('store'); 
                }; 
                req.onsuccess = (e) => { this.db = e.target.result; resolve(); }; 
                req.onerror = (e) => reject(e); 
            }); 
        },
        async get(key) { if(!this.db) await this.init(); return new Promise((resolve) => { const tx = this.db.transaction('store', 'readonly'); const req = tx.objectStore('store').get(key); req.onsuccess = () => resolve(req.result); req.onerror = () => resolve(null); }); },
        async set(key, value) { if(!this.db) await this.init(); return new Promise((resolve) => { const tx = this.db.transaction('store', 'readwrite'); tx.objectStore('store').put(value, key); tx.oncomplete = () => resolve(); }); },
        async delete(key) { if(!this.db) await this.init(); return new Promise((resolve) => { const tx = this.db.transaction('store', 'readwrite'); tx.objectStore('store').delete(key); tx.oncomplete = () => resolve(); }); }
    };

    const RAPID_KEYS = ["d1edce158amshec139440d20658ap1f2545jsnbb7da9add82f","6cf7f03014msh787c51a713c0264p15c20djsna1f9a9f6a378","13d48f6bb8msh459c11b91bdcc44p110f4ejsn099443894115","03fc23317fmsh0535ef9ec8c6f5bp1db59bjsn545991df9343","e54e3fbc4dmshfc16d4417b618fdp1a2fafjsn30c72d8cf3ab","2f3f6a9ae2mshdc5288abadb0c84p118401jsnd18970b2f26a","c1efbc2580mshf9e6f81b0e6f996p143edajsn64cf72ed1463","da6bd1e90dmsh5aab26c0416ad7ep182d57jsnee8be14e0c74","7dd1f2fad7msh74af897174e65bcp10834ejsnc62fe7ef2611","2f4d50852bmsh18208c6cdabf7d5p1c8a68jsn6c3a2b8fa7b8","d3c96044bfmshfb83354c3708e98p1ed394jsnbf4ef41a0837"];
    let rapidKeyIdx = 0;
    function getRapidKey() { return RAPID_KEYS[rapidKeyIdx]; }
    function rotateRapidKey() { rapidKeyIdx = (rapidKeyIdx + 1) % RAPID_KEYS.length; console.log("Rotated API Key"); }
    const RAPID_API_HOST = "spotify81.p.rapidapi.com";
    const APP_LOGO_URL = "https://i.ibb.co/zhg1w3dw/file-00000000aca472308a4675a6979753cb.png";
    const BASE_API = "https://ayushm-psi.vercel.app/api";

    // Direct Stream API Constants
    const YT_STREAM_KEYS = ["6cf7f03014msh787c51a713c0264p15c20djsna1f9a9f6a378"];
    const YT_STREAM_HOST = "ytstream-download-youtube-videos.p.rapidapi.com";

    const state = { 
        lang: 'hindi', quality: '320kbps', videoQuality: 'medium', isPlaying: false, queue: [], qIndex: 0, currentTrackId: null, isShuffle: false, isLoop: false, playSessionId: 0, currentAlbumData: null, lyricsData: null, activeLyricIndex: -1, showCanvas: true, showLyrics: true, metaFetchId: 0, downloadState: { active: false, abort: null, id: null }, bufferingId: null,
        videoMode: false, currentTrackYTId: null, videoSwitching: false, isDirectVideo: false 
    };
    const languages = ["Hindi", "English", "Punjabi", "Tamil", "Telugu", "Marathi", "Gujarati", "Bengali", "Kannada", "Bhojpuri", "Malayalam", "Haryanvi", "Rajasthani", "Odia", "Assamese"];
    const PROXY_LIST = ["https://corsproxy.io/?", "https://api.allorigins.win/raw?url=", "https://thingproxy.freeboard.io/fetch/"];
    
    async function fetchWithFallback(url) {
        for (const proxy of PROXY_LIST) { try { const res = await fetch(proxy + encodeURIComponent(url)); if (!res.ok) throw new Error(`Proxy failed`); return res; } catch (e) {} }
        try { return await fetch(url); } catch(e) { throw new Error("All fetches failed"); }
    }
    
    async function fetchBlob(url) {
         try {
             const res = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
             if(!res.ok) throw new Error("Proxy fail");
             return await res.blob();
         } catch(e) {
             return fetch(url).then(r => r.blob());
         }
    }

    // --- REPLACE YOUR EXISTING VARIABLE BLOCK WITH THIS ---
let audioCtx, audioSource, eqBands = [], preGainNode, eqMode = 0;
// NEW VARIABLES FOR ENHANCEMENT:
let compressorNode, pannerNode, filterNode, gainNode8D, pannerInterval;

const eqPresets = [[0,0,0,0,0,0,0,0,0,0], [10, 12, 6, -2, -2, 0, 0, 0, 3, 3], [4, 3, 1, -1, -2, 0, 3, 5, 6, 6], [3, 3, 1, 0, 0, 0, 0, 1, 2, 2]];
const djFrequencies = [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000];
const audio = new Audio(); audio.crossOrigin = "anonymous";
let likedSongs = [], savedPlaylists = [], downloads = [], offlinePlaylists = [], searchCache = {}, metaCache = {}, wakeLock = null;
let globalLoadRequestId = 0;

    // YOUTUBE PLAYER VARS
    let ytPlayer, ytDragging = false, ytLooped = false, ytHideTimer = null;

    function decodeStr(html) { if (!html) return ""; const txt = document.createElement("textarea"); txt.innerHTML = html; return txt.value; }
    
    function extractImg(img, size = '500') {
        let url = '';
        if(Array.isArray(img)) {
            const best = img[img.length-1];
            url = best.url || best.link;
        } else {
            url = img;
        }

        if(!url) return `https://via.placeholder.com/${size}`;
        
        return url
            .replace('150x150', `${size}x${size}`)
            .replace('50x50', `${size}x${size}`)
            .replace('500x500', `${size}x${size}`);
    }
    function getArtistName(data) {
        if (!data) return "Unknown Artist";
        if (data.artists && data.artists.primary && Array.isArray(data.artists.primary)) return data.artists.primary.map(a => a.name).join(', ');
        if (data.primary_artists) return data.primary_artists; 
        if (data.primaryArtists) return data.primaryArtists;
        if (data.singers) return data.singers;
        if (data.subtitle) return data.subtitle;
        return "Unknown Artist";
    }

    function updateMediaSessionPosition() {
        if ('mediaSession' in navigator) {
            let duration = state.videoMode && ytPlayer && ytPlayer.getDuration ? ytPlayer.getDuration() : audio.duration;
            let currentTime = state.videoMode && ytPlayer && ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : audio.currentTime;
            
            if (duration && !isNaN(duration)) {
                try { navigator.mediaSession.setPositionState({ duration: duration, playbackRate: 1, position: currentTime }); } catch(e) {}
            }
        }
    }

    window.addEventListener('load', async () => {
        await IdbHelper.init();
        state.lang = localStorage.getItem('vibeLang') || 'hindi';
        state.quality = localStorage.getItem('vibeQuality') || '320kbps';
        state.videoQuality = localStorage.getItem('vibeVideoQuality') || 'medium'; // Default to 360p
        state.showCanvas = localStorage.getItem('vibeCanvas') !== 'false';
        state.showLyrics = localStorage.getItem('vibeLyrics') !== 'false';
        
        likedSongs = (await IdbHelper.get('vibeLiked')) || [];
        savedPlaylists = (await IdbHelper.get('vibeSavedPlaylists')) || [];
        downloads = (await IdbHelper.get('vibeDownloads')) || [];
        offlinePlaylists = (await IdbHelper.get('vibeOfflinePlaylists')) || [];
        searchCache = (await IdbHelper.get('vibeSearchCache')) || {};
        metaCache = (await IdbHelper.get('vibeMetaCache')) || {};

        document.getElementById('header-lang').innerText = state.lang;
        renderSettingsUI();
        
        const now = Date.now();
        let changed = false;
        Object.keys(metaCache).forEach(k => { if (!metaCache[k].permanent && (now - metaCache[k].ts > 86400000)) { delete metaCache[k]; changed = true; } });
        if(changed) IdbHelper.set('vibeMetaCache', metaCache);

        history.replaceState({view: 'home'}, null, '');
        loadHome();
        setupSwipe(); startMarqueeObserver(); restoreLastSession(); 
        
        audio.addEventListener('timeupdate', () => { 
            if(!state.videoMode) {
                updateProgress(); syncLyrics(); saveSessionState(); 
            }
        });
        audio.addEventListener('ended', () => { 
            if(!state.videoMode) {
                if(state.isLoop) { audio.currentTime=0; audio.play(); } else playNext(); 
            }
        });
        audio.addEventListener('play', () => { 
            state.isPlaying = true; updateIcons(); updateMediaSessionPosition();
            setBuffering(false);
            const mp = document.getElementById('mini-player'); mp.style.display = 'flex';
            setTimeout(() => { mp.style.transform = 'translateY(0)'; mp.style.opacity = '1'; mp.classList.add('show'); }, 50);
            document.getElementById('mini-img').classList.add('spin-anim');
     const vid = document.getElementById('canvas-video');
        const bg = document.getElementById('fp-bg-gradient');
        const imgArea = document.getElementById('fp-img-area');

        // Check if we have a valid source and Canvas is enabled
        if(vid.src && state.showCanvas && !state.videoMode) {
            vid.play().then(() => {
                // SUCCESS: Video is playing. 
                // If in Portrait, Show Video & Hide Art
                if(window.innerHeight > window.innerWidth) {
                    vid.style.opacity = '1';
                    if(bg) bg.style.opacity = '0';
                    if(imgArea) imgArea.style.opacity = '0';
                }
            }).catch(e => {
                // FAIL: Video failed to play. 
                // Force Art & Gradient to show
                console.log("Canvas play error, restoring Art");
                vid.style.opacity = '0';
                if(bg) bg.style.opacity = '1';
                if(imgArea) imgArea.style.opacity = '1';
            });
        } else {
            // NO CANVAS AVAILABLE: Force Art & Gradient to show
            vid.style.opacity = '0';
            if(bg) bg.style.opacity = '1';
            if(imgArea) imgArea.style.opacity = '1';
        }

        if(!audioCtx) initAudioContext(); 
        if(audioCtx.state === 'suspended') audioCtx.resume();
    });
        audio.addEventListener('pause', () => { 
            state.isPlaying = false; updateIcons(); updateMediaSessionPosition(); document.getElementById('mini-img').classList.remove('spin-anim'); document.getElementById('canvas-video').pause(); 
        });
        audio.addEventListener('waiting', () => { if(!state.videoMode) setBuffering(true) });
        audio.addEventListener('playing', () => { if(!state.videoMode) setBuffering(false) });
        audio.addEventListener('loadedmetadata', () => { 
            if(!state.videoMode) {
                document.getElementById('seek-slider').max = audio.duration; document.getElementById('total-time').innerText = fmtTime(audio.duration); updateMediaSessionPosition(); 
            }
        });
        audio.addEventListener('seeked', updateMediaSessionPosition);

        let timer;
        document.getElementById('search-input').addEventListener('input', (e) => { clearTimeout(timer); timer = setTimeout(() => search(e.target.value), 600); });
        
        // Seek Slider Logic (Main Player)
        const slider = document.getElementById('seek-slider');
  slider.addEventListener('change', (e) => { 
            if(state.videoMode) {
                // FORCE 1 SECOND MINIMUM to prevent Ad-Detector false alarm
                let safeTime = Math.max(1, e.target.value); 
                
                if(state.isDirectVideo) {
                    const dv = document.getElementById('direct-video-player');
                    dv.currentTime = safeTime;
                } else if (ytPlayer && ytPlayer.seekTo) {
                    ytPlayer.seekTo(safeTime, true);
                }
            } else {
                audio.currentTime = e.target.value; 
            }
        });

        const cv = document.getElementById('canvas-video');
        
        // --- FIX START: ROBUST CANVAS HANDLING ---
        const handleCanvasPlay = function() { 
            if(!state.showCanvas || state.videoMode) return; 
            if(window.innerWidth > window.innerHeight) return; // Landscape check

            // Only hide Art/BG if video has enough data to play (readyState >= 2)
            if(this.readyState >= 2) {
                if(state.isPlaying) this.play().catch(e => console.log(e)); 
                this.style.opacity = '1'; 
                document.getElementById('fp-bg-gradient').style.opacity = '0'; 
                document.getElementById('fp-img-area').style.opacity = '0'; 
            }
        };

        // Reset UI if Canvas fails to load
        cv.addEventListener('error', () => {
            console.log("Canvas failed, restoring UI");
            cv.style.opacity = '0';
            document.getElementById('fp-bg-gradient').style.opacity = '1'; 
            document.getElementById('fp-img-area').style.opacity = '1';
        });
        // --- FIX END ---

        cv.addEventListener('canplay', handleCanvasPlay); 
        cv.addEventListener('play', handleCanvasPlay);
        cv.addEventListener('playing', handleCanvasPlay); // Added 'playing' for extra safety
        setupGestures();
        
        // Setup new YT Gestures
        const blockTap = document.getElementById('blockTap');
        const centerTap = document.getElementById('centerTap');
        const bar = document.getElementById('yt-bar');
        const controls = document.getElementById("yt-controls");

        function showYTControls(){
            controls.classList.remove("hide");
            controls.classList.add("show");
            clearTimeout(ytHideTimer);
            ytHideTimer = setTimeout(() => {
                controls.classList.remove("show");
                controls.classList.add("hide");
            }, 2500);
        }

        blockTap.addEventListener('pointerdown', e => { e.preventDefault(); showYTControls(); });
        centerTap.addEventListener('pointerdown', e => {
            e.preventDefault();
            toggleYtPlay();
            showYTControls();
        });

    function ytSeek(x) {
            let r = bar.getBoundingClientRect();
            let p = Math.max(0, Math.min(1, (x - r.left) / r.width));
            
            if(state.isDirectVideo) {
                const dv = document.getElementById('direct-video-player');
                if(dv && dv.duration) {
                    // Force minimum 1 second
                    let t = dv.duration * p;
                    dv.currentTime = Math.max(1, t); 
                }
            } else if(ytPlayer && ytPlayer.getDuration) {
                let t = ytPlayer.getDuration() * p;
                // Force minimum 1 second
                ytPlayer.seekTo(Math.max(2, t), true); 
            }
        }

        bar.addEventListener('pointerdown', e => { ytDragging = true; showYTControls(); ytSeek(e.clientX); });
        bar.addEventListener('pointermove', e => { if(ytDragging) ytSeek(e.clientX); });
        window.addEventListener('pointerup', () => { ytDragging = false; });
        
        // Auto Switch to Audio on Minimize/Home
        document.addEventListener('visibilitychange', () => {
             if (document.hidden && state.videoMode) {
                 toggleVideoMode();
             }
        });
    });

    async function requestWakeLock() { try { if ('wakeLock' in navigator) { wakeLock = await navigator.wakeLock.request('screen'); } } catch (err) { console.log(err); } }
    function releaseWakeLock() { if (wakeLock) { wakeLock.release(); wakeLock = null; } }

    let lastSaveTime = 0;
    function saveSessionState() {
        const now = Date.now(); if (now - lastSaveTime < 2000) return; lastSaveTime = now;
        let cTime = state.videoMode ? (state.isDirectVideo ? document.getElementById('direct-video-player').currentTime : (ytPlayer ? ytPlayer.getCurrentTime() : 0)) : audio.currentTime;
        IdbHelper.set('vibeSession', { queue: state.queue, qIndex: state.qIndex, currentTime: cTime, trackId: state.currentTrackId });
    }

    async function restoreLastSession() {
        const session = await IdbHelper.get('vibeSession'); if (!session || !session.queue || session.queue.length === 0) return;
        state.queue = session.queue; state.qIndex = session.qIndex; state.currentTrackId = session.trackId;
        const track = state.queue[state.qIndex];
        if (track) {
            updateUI(track);
            let blobKey = `blob_audio_${track.id}_${state.quality}`;
            let blob = await IdbHelper.get(blobKey);
            if (!blob) { blobKey = `blob_audio_${track.id}_320kbps`; blob = await IdbHelper.get(blobKey); }
            if (blob) { audio.src = URL.createObjectURL(blob); } 
            else {
                let src = track.mediaUrl;
                if (!src && track.downloadUrl) { 
                    if(Array.isArray(track.downloadUrl)) { const found = track.downloadUrl.find(x => x.quality === state.quality) || track.downloadUrl[track.downloadUrl.length-1]; src = found.url || found.link; }
                    else src = track.downloadUrl;
                }
                if (src) audio.src = src;
            }
            audio.currentTime = session.currentTime || 0;
            const mp = document.getElementById('mini-player'); mp.style.display = 'flex'; mp.style.transform = 'translateY(0)'; mp.style.opacity = '1';
            const cachedMeta = metaCache[track.id];
            if (cachedMeta) { 
                if(cachedMeta.lyricsData && state.showLyrics) { state.lyricsData = cachedMeta.lyricsData; document.getElementById('mini-lyrics-player').style.display = 'block'; document.getElementById('mini-lyric-text').innerText = "Lyrics ready"; renderFullLyrics(); } 
                if(cachedMeta.canvasUrl && state.showCanvas) document.getElementById('canvas-video').src = cachedMeta.canvasUrl; 
            }
            // Check cache for YouTube ID
            if(cachedMeta && cachedMeta.ytId) { state.currentTrackYTId = cachedMeta.ytId; }
            else { fetchYouTubeId(track.title, track.artist, track.id, track.rawData?.label); }
        }
    }

    function renderSettingsUI() {
        const langGrid = document.getElementById('lang-grid'); langGrid.innerHTML = '';
        languages.forEach(l => { const btn = document.createElement('div'); btn.className = `chip-btn ${state.lang === l.toLowerCase() ? 'active' : ''}`; btn.innerText = l; btn.onclick = () => updateLang(l.toLowerCase()); langGrid.appendChild(btn); });
        
        // Update Audio Quality Buttons
        document.querySelectorAll('#quality-row .quality-btn').forEach(btn => { if(btn.getAttribute('onclick').includes(state.quality)) btn.classList.add('active'); else btn.classList.remove('active'); });
        
        // Update Video Quality Buttons
        document.querySelectorAll('#video-quality-row .quality-btn').forEach(btn => { if(btn.getAttribute('onclick').includes(state.videoQuality)) btn.classList.add('active'); else btn.classList.remove('active'); });

        document.getElementById('toggle-canvas').checked = state.showCanvas; document.getElementById('toggle-lyrics').checked = state.showLyrics;
    }

    function toggleSetting(type) {
        if (type === 'canvas') { state.showCanvas = document.getElementById('toggle-canvas').checked; localStorage.setItem('vibeCanvas', state.showCanvas); showToast(`Canvas ${state.showCanvas ? 'Enabled' : 'Disabled'}`); if(!state.showCanvas) { document.getElementById('canvas-video').style.opacity = '0'; document.getElementById('canvas-video').pause(); document.getElementById('fp-img-area').style.opacity = '1'; document.getElementById('fp-bg-gradient').style.opacity = '1'; document.getElementById('full-player').classList.remove('canvas-immersive'); } }
        else if (type === 'lyrics') { state.showLyrics = document.getElementById('toggle-lyrics').checked; localStorage.setItem('vibeLyrics', state.showLyrics); showToast(`Lyrics ${state.showLyrics ? 'Enabled' : 'Disabled'}`); if(!state.showLyrics) document.getElementById('mini-lyrics-player').style.display = 'none'; else if(state.lyricsData) document.getElementById('mini-lyrics-player').style.display = 'block'; }
    }

    function updateLang(l) { state.lang = l; localStorage.setItem('vibeLang', l); document.getElementById('header-lang').innerText = l; IdbHelper.delete(`vibe_home_cache_${state.lang}`); renderSettingsUI(); loadHome(); }
    function updateQuality(q) { state.quality = q; localStorage.setItem('vibeQuality', q); renderSettingsUI(); showToast(`Audio Quality: ${q}`); }
    
    function updateVideoQuality(q) {
        state.videoQuality = q;
        localStorage.setItem('vibeVideoQuality', q);
        renderSettingsUI();
        let displayTxt = "Auto";
        if (q === 'hd1080') displayTxt = "Up to 1080p";
        else if (q === 'hd720') displayTxt = "Up to 720p";
        else if (q === 'large') displayTxt = "Up to 480p";
        else if (q === 'medium') displayTxt = "Up to 360p";
        showToast(`Video limit: ${displayTxt}`);
        
        if(ytPlayer && ytPlayer.setPlaybackQuality) ytPlayer.setPlaybackQuality(q);
    }

    window.addEventListener('popstate', (e) => {
        const fullPlayer = document.getElementById('full-player'), albumView = document.getElementById('album-view'), lyrics = document.getElementById('full-lyrics-view'), artistView = document.getElementById('artist-view');
        if (lyrics.classList.contains('active')) { lyrics.classList.remove('active'); releaseWakeLock(); return; }
        if (fullPlayer.classList.contains('active')) { 
             // Switch to audio if closing full player while in video mode
             if (state.videoMode) toggleVideoMode();
             fullPlayer.classList.remove('active', 'canvas-immersive'); 
             return; 
        }
        if (albumView.classList.contains('active')) { albumView.classList.remove('active'); return; }
        if (artistView.classList.contains('active')) { artistView.classList.remove('active'); return; }
    });

    function goBack() { 
        if (document.getElementById('full-lyrics-view').classList.contains('active')) closeFullLyrics();
        else if (document.getElementById('full-player').classList.contains('active')) { 
            // Switch to audio if closing full player
            if (state.videoMode) toggleVideoMode();
            history.back(); 
        }
        else if (document.getElementById('album-view').classList.contains('active')) { history.back(); }
        else if (document.getElementById('artist-view').classList.contains('active')) { history.back(); }
        else history.back(); 
    }

    function startMarqueeObserver() {
        const checkMarquee = (el) => {
            const container = el.parentElement; if (!container) return;
            el.classList.remove('animate-pingpong', 'animate-scroll'); el.style.transform = 'translateX(0)';
            const textWidth = el.scrollWidth, boxWidth = container.offsetWidth;
            if (textWidth > boxWidth) {
                const dist = textWidth - boxWidth + 20; const duration = Math.max(5, dist * 0.05 + 3);
                el.style.setProperty('--container-width', `${boxWidth}px`); el.style.setProperty('--scroll-dist', `-${dist}px`); el.style.setProperty('--duration', `${duration}s`);
                const isMainPlayer = el.id === 'fp-title' || el.id === 'fp-artist';
                if (isMainPlayer) { el.classList.add('animate-scroll'); if(container) container.style.justifyContent = 'flex-start'; } else { el.classList.add('animate-pingpong'); }
            } else if (el.id === 'fp-title' || el.id === 'fp-artist') { if(container) container.style.justifyContent = 'center'; }
        };
        const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) checkMarquee(entry.target); else { entry.target.classList.remove('animate-pingpong', 'animate-scroll'); entry.target.style.transform = 'translateX(0)'; } }); }, { threshold: 0.1 });
        window.observeMarquees = () => { document.querySelectorAll('.marquee-content').forEach(el => observer.observe(el)); }; setInterval(window.observeMarquees, 2000);
    }

    async function getHomeCache(lang) { try { const key = `vibe_home_cache_${lang}`; const cached = await IdbHelper.get(key); if(!cached) return null; if(Date.now() - cached.timestamp > 7200000) return null; return cached.data; } catch(e) { return null; } }
    function setHomeCache(lang, data) { IdbHelper.set(`vibe_home_cache_${lang}`, { timestamp: Date.now(), data: data }); }

    function setupSwipe() {
        const mp = document.getElementById('mini-player');
        let startX = 0, currentX = 0, isDragging = false, isDragIntent = false;
        mp.addEventListener('touchstart', (e) => { startX = e.touches[0].clientX; isDragging = true; isDragIntent = false; mp.classList.remove('mp-smooth'); }, { passive: false });
        mp.addEventListener('touchmove', (e) => { if (!isDragging) return; currentX = e.touches[0].clientX; let diff = currentX - startX; if (Math.abs(diff) > 5) { isDragIntent = true; } if (isDragIntent && e.cancelable) e.preventDefault(); if (diff < 0) diff = 0; mp.style.transform = `translateX(${diff}px)`; mp.style.opacity = Math.max(0, 1 - (diff / (window.innerWidth * 0.8))); }, { passive: false });
        mp.addEventListener('touchend', () => { isDragging = false; mp.classList.add('mp-smooth'); const diff = currentX - startX; if (isDragIntent && diff > window.innerWidth * 0.35) { mp.style.transform = `translateX(100%)`; mp.style.opacity = 0; audio.pause(); state.isPlaying = false; setTimeout(() => { mp.style.display = 'none'; mp.style.transform = 'translateY(200%)'; }, 300); } else { mp.style.transform = `translateX(0)`; mp.style.opacity = 1; } });
        mp.addEventListener('click', (e) => { if (!isDragIntent && !e.target.closest('button') && !e.target.closest('.mp-heart')) openFullPlayer(); });
    }

    // Helper: Loads a specific section and shows a Retry button on failure
    async function loadSection(el, url, showLogo) {
        el.innerHTML = '<div class="loader"></div>';
        try {
            const data = await fetchJina(url);
            // If Jina fails, it often returns empty array, so we treat empty as an error to allow retry
            if (!data || data.length === 0) throw new Error("Load failed");
            renderGrid(el, data, showLogo);
            return data;
        } catch (e) {
            el.innerHTML = '';
            // Create Retry UI
            const div = document.createElement('div');
            div.style.cssText = "display:flex;flex-direction:column;align-items:center;padding:20px;gap:10px;width:100%;";
            div.innerHTML = '<span style="font-size:12px;color:#666;">Failed to load</span>';
            
            const btn = document.createElement('button');
            btn.innerText = "Retry";
            btn.style.cssText = "padding:6px 16px;background:#1e222b;border:1px solid #333;color:white;border-radius:20px;font-size:11px;font-weight:600;cursor:pointer;pointer-events:auto;";
            
            // Re-trigger this specific function on click
            btn.onclick = () => loadSection(el, url, showLogo);
            
            div.appendChild(btn);
            el.appendChild(div);
            return null;
        }
    }

    async function loadHome() {
        const rel = document.getElementById('new-releases'), chart = document.getElementById('top-charts'), play = document.getElementById('top-playlists');
        
        // 1. Check Cache
        const cachedData = await getHomeCache(state.lang);
        if(cachedData) { 
            renderGrid(rel, cachedData.releases, false); 
            renderGrid(chart, cachedData.charts, true); 
            renderGrid(play, cachedData.playlists, true); 
            return; 
        }

        // 2. Load Sections in Parallel with Independent Retry Logic
        const [d1, d2, d3] = await Promise.all([
            loadSection(rel, `https://www.jiosaavn.com/new-releases/${state.lang}`, false),
            loadSection(chart, `https://www.jiosaavn.com/charts`, true),
            loadSection(play, `https://www.jiosaavn.com/featured-playlists/${state.lang}`, true)
        ]);

        // 3. Update Cache only if everything loaded successfully
        if (d1 && d2 && d3) {
            setHomeCache(state.lang, { releases: d1, charts: d2, playlists: d3 });
        }
    }
    async function fetchJina(url) { const res = await fetch(`https://r.jina.ai/${url}`); const text = await res.text(); return parseJina(text); }
    function parseJina(text) {
        const regex = /\[!\[(.*?)\]\((.*?)\)\]\((.*?)\)/g; 
        const items = []; 
        let match;
        while ((match = regex.exec(text)) !== null) { 
            let title = decodeStr(match[1].replace(/Image \d+: /, '').split(']')[0].trim()); 
            // FIX: Use extractImg with '250' to force resize, handling cases where source is 500x500
            let rawImg = match[2].split('?')[0];
            let img = extractImg(rawImg, '250');
            
            let link = match[3]; 
            let type = 'song'; 
            if(link.includes('/album/')) type = 'album'; 
            else if(link.includes('/featured') || link.includes('/playlist')) type = 'playlist'; 
            items.push({ title, img, link, type }); 
        }
        return items;
    }
    function renderGrid(el, items, showLogo = false) {
        el.innerHTML = ''; if (!items || !items.length) { el.innerHTML = '<p style="padding:10px; color:#666; font-size:12px;">No items</p>'; return; }
        items.forEach(item => { const div = document.createElement('div'); div.className = 'card'; let logoHtml = showLogo ? `<img src="${APP_LOGO_URL}" class="card-logo">` : ''; div.innerHTML = `${logoHtml}<img src="${item.img}" loading="lazy"><div class="marquee-container"><h3 class="marquee-content">${decodeStr(item.title)}</h3></div><p>${item.type}</p>`; div.onclick = () => handleClick(item, showLogo); el.appendChild(div); }); window.observeMarquees();
    }

    async function search(q) {
        const resEl = document.getElementById('search-results'); if(!q.trim()) { resEl.innerHTML = ''; return; } resEl.innerHTML = '<div class="loader"></div>';
        if(searchCache[q]) { renderSearchResults(searchCache[q]); return; }
        try {
            const [songRes, genRes, artistRes] = await Promise.all([
                fetch(`${BASE_API}/search/songs?query=${encodeURIComponent(q)}`),
                fetch(`${BASE_API}/search/albums?query=${encodeURIComponent(q)}`),
                fetch(`${BASE_API}/search/artists?query=${encodeURIComponent(q)}`)
            ]);
            const songJson = await songRes.json();
            const albumJson = await genRes.json();
            const artistJson = await artistRes.json();
            const playlistRes = await fetch(`${BASE_API}/search/playlists?query=${encodeURIComponent(q)}`);
            const playlistJson = await playlistRes.json();

            const results = { 
                songs: songJson.data.results, 
                albums: albumJson.data.results, 
                playlists: playlistJson.data.results,
                artists: artistJson.data.results 
            };
            
            searchCache[q] = results; IdbHelper.set('vibeSearchCache', searchCache); renderSearchResults(results);
        } catch(e) { console.error(e); resEl.innerHTML = '<p style="text-align:center;">Error</p>'; }
    }

    function renderSearchResults(data) {
        const resEl = document.getElementById('search-results'); resEl.innerHTML = '';
        if(data.songs && data.songs.length > 0) {
            const header = document.createElement('div'); header.className = 'search-header'; header.innerText = 'Songs'; resEl.appendChild(header);
            data.songs.forEach(s => {
                const div = document.createElement('div'); div.className = 'list-item';
                const img =  extractImg(s.image, '50'); 
                const title = decodeStr(s.name || s.title);
                const artist = getArtistName(s);
                const isPlaying = state.currentTrackId === s.id;
                div.innerHTML = `<img src="${img}"> <div class="list-info"><div class="marquee-container"><h4 class="marquee-content ${isPlaying?'text-green':''}">${title}</h4></div><div class="marquee-container"><p class="marquee-content">${artist}</p></div></div>`;
                div.onclick = () => playSong(s.id, null, { ...s, title, subtitle: artist, img });
                resEl.appendChild(div);
            });
        }
        if(data.albums && data.albums.length > 0) {
            const header = document.createElement('div'); header.className = 'search-header'; header.innerText = 'Albums'; resEl.appendChild(header);
            const gridDiv = document.createElement('div'); gridDiv.className = 'grid-scroll';
            data.albums.forEach(a => {
                const div = document.createElement('div'); div.className = 'card';
                const img = extractImg(a.image, '250');
                const title = decodeStr(a.name || a.title);
                const albumUrl = a.url || a.perma_url || "";
                div.innerHTML = `<img src="${img}"><div class="marquee-container"><h3 class="marquee-content">${title}</h3></div><p>Album</p>`;
                div.onclick = () => openCollection('album', albumUrl, { title, img, subtitle: 'Album' });
                gridDiv.appendChild(div);
            });
            resEl.appendChild(gridDiv);
        }
        if(data.artists && data.artists.length > 0) {
            const header = document.createElement('div'); header.className = 'search-header'; header.innerText = 'Artists'; resEl.appendChild(header);
            const gridDiv = document.createElement('div'); gridDiv.className = 'grid-scroll';
            data.artists.forEach(a => {
                const div = document.createElement('div'); div.className = 'card circle-img';
                const img = extractImg(a.image, '250');
                const name = decodeStr(a.name);
                div.innerHTML = `<img src="${img}"><div class="marquee-container"><h3 class="marquee-content">${name}</h3></div><p>Artist</p>`;
                div.onclick = () => openArtist(a.id);
                gridDiv.appendChild(div);
            });
            resEl.appendChild(gridDiv);
        }
        if(data.playlists && data.playlists.length > 0) {
            const header = document.createElement('div'); header.className = 'search-header'; header.innerText = 'Playlists'; resEl.appendChild(header);
            const gridDiv = document.createElement('div'); gridDiv.className = 'grid-scroll';
            data.playlists.forEach(a => {
                const div = document.createElement('div'); div.className = 'card';
                const img = extractImg(a.image, '250');
                const title = decodeStr(a.name || a.title);
                const plUrl = a.url || a.perma_url || "";
                let logoHtml = `<img src="${APP_LOGO_URL}" class="card-logo">`;
                div.innerHTML = `${logoHtml}<img src="${img}"><div class="marquee-container"><h3 class="marquee-content">${title}</h3></div><p>Playlist</p>`;
                div.onclick = () => openCollection('playlist', plUrl, { title, img, subtitle: 'Playlist' }, false, true);
                gridDiv.appendChild(div);
            });
            resEl.appendChild(gridDiv);
        }
        window.observeMarquees();
    }

    async function playSong(id, fullUrl, preData = null) {
        try {
            if(id) {
                state.bufferingId = id;
                const el = document.querySelector(`.list-item[onclick*="${id}"]`);
                if(el) { el.classList.add('buffering'); }
            }

            let trackData = {};
            if (preData && preData.downloadUrl) {
                trackData = { id: preData.id, title: decodeStr(preData.title || preData.name), artist: getArtistName(preData), img: preData.img, downloadUrl: preData.downloadUrl, url: preData.url, rawData: preData };
            } else if (id) {
                const res = await fetch(`${BASE_API}/songs/${id}`);
                const json = await res.json();
                const data = Array.isArray(json.data) ? json.data[0] : json.data;
                let img = extractImg(data.image);
                trackData = { id: data.id, title: decodeStr(data.name), artist: getArtistName(data), img: img, downloadUrl: data.downloadUrl, url: data.url, rawData: data };
            } else if (fullUrl) {
                const res = await fetch(`${BASE_API}/songs?link=${encodeURIComponent(fullUrl)}`);
                const json = await res.json();
                const data = Array.isArray(json.data) ? json.data[0] : json.data;
                let img = extractImg(data.image);
                trackData = { id: data.id, title: decodeStr(data.name), artist: getArtistName(data), img: img, downloadUrl: data.downloadUrl, url: data.url, rawData: data };
            }
            
            state.queue = [trackData]; state.qIndex = 0; 
            loadAndPlay();
            
            const albumUrl = trackData.rawData.album_url || (trackData.rawData.album && trackData.rawData.album.url);
            if(albumUrl && !state.currentAlbumData) { fetchAlbumAndQueue(albumUrl, trackData.id); }

        } catch(e) { console.error(e); showToast("Failed to play song"); setBuffering(false); }
    }

    function setBuffering(isBuffering) {
        document.querySelectorAll('.list-item').forEach(el => el.classList.remove('buffering'));
        if (isBuffering && state.bufferingId) {
            // Already handled in click or playSong via class addition.
            // This function is mainly for clearing or network events.
        }
    }

    async function fetchAlbumAndQueue(url, currentSongId) {
        try {
            if(url.indexOf('http') !== 0) url = `https://www.jiosaavn.com${url}`;
            const apiEndpoint = url.includes('/playlist/') || url.includes('/featured/') ? `${BASE_API}/playlists?link=` : `${BASE_API}/albums?link=`;
            const res = await fetch(`${apiEndpoint}${encodeURIComponent(url)}`);
            const json = await res.json();
            const data = json.data || json;
            let songs = data.songs || data.list || [];
            
            if(songs.length > 1) {
                 const newQueue = songs.map(s => {
                    let sImg = extractImg(s.image);
                    s.album = s.album || data.name || data.title;
                    s.album_url = s.album_url || data.perma_url || data.url;
                    let dUrl = s.downloadUrl; if (!dUrl && s.media_url) { dUrl = [{ link: s.media_url, quality: "320kbps" }]; }
                    return { id: s.id, title: decodeStr(s.name || s.title || s.song), artist: getArtistName(s), img: sImg, mediaUrl: s.media_url, downloadUrl: dUrl, url: s.url, rawData: s };
                });
                const idx = newQueue.findIndex(s => s.id === currentSongId);
                if(idx !== -1) { state.queue = newQueue; state.qIndex = idx; state.queue[idx] = { ...state.queue[idx], ...state.queue[state.qIndex] }; console.log("Context loaded: " + newQueue.length + " songs"); }
            }
        } catch(e) { console.log("Background context load failed", e); }
    }

    async function loadAndPlay() {
        // CLEANUP VIDEO PLAYER IF EXISTS
        if (ytPlayer) {
            try { ytPlayer.destroy(); } catch(e){}
            ytPlayer = null;
        }
        // Cleanup Direct Video
        const dv = document.getElementById('direct-video-player');
        dv.pause();
        dv.style.display = 'none';
        dv.src = '';
        state.isDirectVideo = false;
        
        state.videoMode = false;
        document.getElementById('yt-view-container').classList.remove('active');
        document.getElementById('fp-art').classList.add('active');
        document.getElementById('fp-bg-gradient').style.opacity = '1';
        document.getElementById('fp-img-area').style.opacity = '1';
        document.getElementById('full-player').classList.remove('canvas-immersive');

        state.metaFetchId++; const currentFetchId = state.metaFetchId;
        const track = state.queue[state.qIndex]; if(!track) return;
        
        state.bufferingId = track.id;
        refreshCurrentListView(); 

        state.playSessionId++; state.currentTrackId = track.id;
        
        // 1. CRITICAL FIX: Reset the YouTube ID immediately
        state.currentTrackYTId = null; 

        // ... Audio Element src loading logic ...
        let src = null;
        let blobKey = `blob_audio_${track.id}_${state.quality}`;
        let blob = await IdbHelper.get(blobKey);
        if (!blob) { blobKey = `blob_audio_${track.id}_320kbps`; blob = await IdbHelper.get(blobKey); }
        
        if (blob) {
            src = URL.createObjectURL(blob);
        } else {
            src = track.mediaUrl;
            if (!src && track.downloadUrl) { 
                if (Array.isArray(track.downloadUrl)) { const found = track.downloadUrl.find(x => x.quality === state.quality) || track.downloadUrl[track.downloadUrl.length-1]; src = found.url || found.link; } 
                else { src = track.downloadUrl; }
            }
        }
        
        if(src) { 
            audio.src = src; 
            audio.play().catch(e => { console.log(e); setBuffering(false); }); 
        } else {
            setBuffering(false);
        }
        updateUI(track);

        const vid = document.getElementById('canvas-video'); vid.style.opacity = '0'; vid.src = "";

    state.lyricsData = null; state.activeLyricIndex = -1;
        document.getElementById('mini-lyrics-player').style.display = 'none'; document.getElementById('mini-lyric-text').innerText = "Loading lyrics...";
        document.getElementById('flyrics-content').innerHTML = "<p style='text-align:center; padding-top:50px; color:#666;'>Loading...</p>";
        document.getElementById('immersive-lyric').innerText = "";
        document.getElementById('ls-lyric-line').innerText = ""; /* Clears Landscape Lyrics */    

        const cachedMeta = metaCache[track.id];
        
        // 2. Logic to handle Metadata and YT ID
        if (cachedMeta) {
            if (cachedMeta.canvasUrl && state.showCanvas) vid.src = cachedMeta.canvasUrl;
            if (cachedMeta.lyricsData) { state.lyricsData = cachedMeta.lyricsData; if(state.showLyrics) { document.getElementById('mini-lyrics-player').style.display = 'block'; document.getElementById('mini-lyric-text').innerText = "Lyrics ready"; renderFullLyrics(); } }
            
            // If cached, set it. If NOT, it remains NULL (safe).
            if (cachedMeta.ytId) {
                state.currentTrackYTId = cachedMeta.ytId;
            } else {
                // Not in cache, fetch background
                fetchYouTubeId(track.title, track.artist, track.id, track.rawData?.label); 
            }
        } else { 
            fetchMeta(track.title, track.artist, track.id, currentFetchId); 
            // Fetch YT ID in background
            fetchYouTubeId(track.title, track.artist, track.id, track.rawData?.label);
        }
    }

    async function fetchMeta(title, artist, trackId, fetchId) {
        if (!state.showCanvas && !state.showLyrics) return;
        try {
            const searchArtist = artist ? artist.split(',').slice(0, 2).join(' ') : "";
            const query = `${title} ${searchArtist}`.trim();
            const searchUrl = `https://${RAPID_API_HOST}/search?q=${encodeURIComponent(query)}&type=tracks&offset=0&limit=25&numberOfTopResults=5`;
            
            const response = await fetch(searchUrl, { method: 'GET', headers: { 'x-rapidapi-key': getRapidKey(), 'x-rapidapi-host': RAPID_API_HOST } });
            
            if (!response.ok) {
                 if (response.status === 429 || response.status === 401 || response.status === 403) {
                     rotateRapidKey();
                     const retryRes = await fetch(searchUrl, { method: 'GET', headers: { 'x-rapidapi-key': getRapidKey(), 'x-rapidapi-host': RAPID_API_HOST } });
                     if(!retryRes.ok) return;
                     var data = await retryRes.json();
                 } else { return; }
            } else { var data = await response.json(); }

            if (state.metaFetchId !== fetchId) return;
            if (state.currentTrackId !== trackId) return;

            const match = performMatching(data, title, artist); if(!match) return;
            const spotifyId = match.id; const spotifyUrl = `https://open.spotify.com/track/${spotifyId}`;
            const promises = []; const resultKeys = [];
            if(state.showCanvas) { promises.push(fetchCanvas(spotifyId)); resultKeys.push('canvas'); }
            if(state.showLyrics) { promises.push(fetchLyrics(spotifyUrl)); resultKeys.push('lyrics'); }
            const results = await Promise.allSettled(promises);
            
            if (state.metaFetchId !== fetchId) return;
            if (state.currentTrackId !== trackId) return; 

            let newCacheEntry = metaCache[trackId] || { ts: Date.now(), permanent: false };
            if(downloads.some(d => d.id === trackId)) newCacheEntry.permanent = true;
            let hasData = false;
            results.forEach((res, index) => { if(res.status === 'fulfilled' && res.value) { if(resultKeys[index] === 'canvas') newCacheEntry.canvasUrl = res.value; if(resultKeys[index] === 'lyrics') newCacheEntry.lyricsData = res.value; hasData = true; } });
            if (hasData) { 
                metaCache[trackId] = newCacheEntry; IdbHelper.set('vibeMetaCache', metaCache); 
                 if (state.currentTrackId === trackId && !state.videoMode) {
                     if(newCacheEntry.canvasUrl && state.showCanvas) document.getElementById('canvas-video').src = newCacheEntry.canvasUrl;
                     if(newCacheEntry.lyricsData) {
                         state.lyricsData = newCacheEntry.lyricsData;
                         if(state.showLyrics) { document.getElementById('mini-lyrics-player').style.display = 'block'; document.getElementById('mini-lyric-text').innerText = "Lyrics ready"; renderFullLyrics(); }
                     }
                 }
            }
        } catch(e) { console.log("Meta fetch failed", e); }
    }

    function performMatching(apiData, targetTrack, targetArtist) {
        if (!apiData.tracks || apiData.tracks.length === 0) return null;
        const clean = (s) => (s || "").toLowerCase().replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").trim();
        const tTitle = clean(targetTrack); const tArtist = clean(targetArtist);
        let bestMatch = null; let highestScore = 0;
        apiData.tracks.forEach(item => {
            const track = item.data; if (!track) return;
            const rTitle = clean(track.name); const rArtists = track.artists.items.map(a => clean(a.profile.name));
            let score = 0; let artistMatched = false;
            if (tArtist.length > 0) {
                for (let ra of rArtists) { if (ra === tArtist) { score += 100; artistMatched = true; break; } else if (ra.includes(tArtist) || tArtist.includes(ra)) { score += 80; artistMatched = true; break; } }
                if (!artistMatched) score = 0;
            } else { score += 50; }
            if (score > 0) { if (rTitle === tTitle) score += 100; else if (rTitle.startsWith(tTitle) || tTitle.startsWith(rTitle)) score += 80; else if (rTitle.includes(tTitle)) score += 50; }
            if (score > highestScore) { highestScore = score; bestMatch = track; }
        });
        return highestScore > 0 ? bestMatch : null;
    }
    
    async function fetchCanvas(id) { try { const scraperUrl = `https://r.jina.ai/https://ayush-gamma-coral.vercel.app/api/canvas?trackId=${id}`; const res = await fetch(scraperUrl); const text = await res.text(); const match = text.match(/\{[\s\S]*\}/); if (!match) return null; const data = JSON.parse(match[0]); const canvasUrl = data?.canvasesList?.[0]?.canvasUrl; if (canvasUrl && state.showCanvas) { if(state.currentTrackId) /* Check inside fetchMeta caller mainly */ ; } return canvasUrl; } catch(e) { return null; } }
    async function fetchLyrics(url) { try { const apiUrl = `https://lyr-nine.vercel.app/api/lyrics?url=${encodeURIComponent(url)}&format=lrc`; const res = await fetch(apiUrl); const data = await res.json(); if (data.lines && data.lines.length > 0) { const parsed = data.lines.map(line => ({ time: parseTimeTag(line.timeTag), text: decodeStr(line.words || "") })); return parsed; } return null; } catch(e) { return null; } }
    function parseTimeTag(tag) { if(!tag) return 0; const parts = tag.split(':'); return (parseInt(parts[0]) * 60) + parseFloat(parts[1]); }

    function renderFullLyrics() { const container = document.getElementById('flyrics-content'); container.innerHTML = ''; if(!state.lyricsData) return; state.lyricsData.forEach((line, index) => { const div = document.createElement('div'); div.className = 'lyric-line l-future'; div.id = `line-${index}`; div.innerText = line.text; div.onclick = () => { audio.currentTime = line.time; }; container.appendChild(div); }); }
    function syncLyrics() {
        if(!state.lyricsData || state.videoMode) return;
        const time = audio.currentTime; let activeIdx = -1;
        for(let i = 0; i < state.lyricsData.length; i++) { if(time >= state.lyricsData[i].time) activeIdx = i; else break; }
        
        if(activeIdx !== state.activeLyricIndex) {
            state.activeLyricIndex = activeIdx;
            if(activeIdx >= 0) { 
                const txt = state.lyricsData[activeIdx].text; 
                // If text is empty or music note, show blank, otherwise show text
                const displayText = (txt === "" || txt === "") ? "" : txt; 
                
                // Update Portrait Elements
                document.getElementById('mini-lyric-text').innerText = displayText || ""; // Keep note for mini player (optional)
                document.getElementById('immersive-lyric').innerText = displayText;
                
                // Update Landscape Element (Multi-line or Blank)
                document.getElementById('ls-lyric-line').innerText = displayText;
                
            } else { 
                // No active lyric yet -> Blank
                document.getElementById('immersive-lyric').innerText = ""; 
                document.getElementById('ls-lyric-line').innerText = ""; 
            }
            if(document.getElementById('full-lyrics-view').classList.contains('active')) updateFullLyricsUI(activeIdx);
        }
    }
    function updateFullLyricsUI(activeIdx) { state.lyricsData.forEach((_, i) => { const el = document.getElementById(`line-${i}`); if(!el) return; el.className = 'lyric-line'; if(i < activeIdx) el.classList.add('l-past'); else if (i === activeIdx) { el.classList.add('l-active'); el.scrollIntoView({ behavior: 'smooth', block: 'center' }); } else el.classList.add('l-future'); }); }
    function openFullLyrics() { 
        document.getElementById('full-lyrics-view').classList.add('active'); 
        history.pushState({view: 'lyrics'}, null, ''); 
        updateFullLyricsUI(state.activeLyricIndex); 
        requestWakeLock(); 

        // --- BACKGROUND LOGIC START ---
        const track = state.queue[state.qIndex];
        if(track) {
            // 1. Set High-Res Image Background
            const rawImg = track.img || 'https://via.placeholder.com/500';
            const hqImg = rawImg.replace('150x150', '500x500').replace('50x50', '500x500').replace('250x250', '500x500');
            document.getElementById('lyric-bg-img').src = hqImg;

            // 2. Set Canvas Video Background (if available & enabled)
            const lyVid = document.getElementById('lyric-bg-video');
            const mainVid = document.getElementById('canvas-video');
            
            // Reset video state
            lyVid.style.opacity = '0';
            lyVid.pause();
            lyVid.src = "";

            // Check if Main Player has a working canvas URL and we are NOT in YouTube video mode
            if(state.showCanvas && !state.videoMode && mainVid.src && mainVid.src.startsWith('http')) {
                lyVid.src = mainVid.src;
                lyVid.load();
                lyVid.play().then(() => {
                    lyVid.style.opacity = '1'; // Fade in video once playing
                }).catch(e => console.log("Lyrics video play failed", e));
            }
        }
        // --- BACKGROUND LOGIC END ---
    }

    function closeFullLyrics() { 
        if (history.state && history.state.view === 'lyrics') history.back(); 
        else document.getElementById('full-lyrics-view').classList.remove('active'); 
        
        // Stop background video to save battery
        const lyVid = document.getElementById('lyric-bg-video');
        if(lyVid) { lyVid.pause(); setTimeout(()=>lyVid.src="", 300); }
        
        releaseWakeLock(); 
    }
    function extractDominantColor(imageUrl) {
    // 1. Create an invisible image in memory (doesn't touch the UI)
    const img = new Image();
    img.crossOrigin = "Anonymous"; 
    
    img.onload = function() {
        try {
            // 2. Create a canvas in memory (doesn't touch the UI)
            const canvas = document.createElement('canvas'); 
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = img.width || 100; 
            canvas.height = img.height || 100;
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            let r=0, g=0, b=0, count=0;
            
            // Sample pixels quickly
            for (let i = 0; i < data.length; i += 40) { 
                r += data[i]; g += data[i+1]; b += data[i+2]; count++; 
            }
            
            if (count > 0) {
                // 3. Apply the color to the CSS variable
                document.documentElement.style.setProperty('--dominant-rgb', `${Math.floor(r/count)}, ${Math.floor(g/count)}, ${Math.floor(b/count)}`);
            }
        } catch (e) { 
            console.warn("Color extraction blocked by image host. Using default."); 
            document.documentElement.style.setProperty('--dominant-rgb', '30, 30, 30');
        }
    };

    img.onerror = function() {
        document.documentElement.style.setProperty('--dominant-rgb', '30, 30, 30');
    };

    // Trigger the invisible image load
    img.src = imageUrl;
}

    function updateUI(track) {
        let displayArtist = track.artist; if(displayArtist) { let artists = displayArtist.split(', '); if(artists.length > 3) displayArtist = artists.slice(0, 3).join(', ') + '...'; }
        
        const mt = document.getElementById('mini-title'), ma = document.getElementById('mini-artist'), ft = document.getElementById('fp-title'), fa = document.getElementById('fp-artist');
        mt.innerText = track.title; ma.innerText = displayArtist; ft.innerText = track.title; fa.innerText = displayArtist; window.observeMarquees();
        
        // --- FORCE HIGH QUALITY IMAGE FOR PLAYERS (500x500) ---
        let rawImg = track.img || 'https://via.placeholder.com/150';
        let hqImg = rawImg.replace('150x150', '500x500').replace('50x50', '500x500'); // Force upgrade
        
        document.getElementById('mini-img').src = hqImg; 
        document.getElementById('fp-art').src = hqImg;
        extractDominantColor(hqImg);
        
        const isLiked = likedSongs.some(s => s.id === track.id);
        ['mini-heart', 'fp-heart'].forEach(id => { const el = document.getElementById(id); if(isLiked) { el.classList.remove('far'); el.classList.add('fas', 'liked'); } else { el.classList.add('far'); el.classList.remove('fas', 'liked'); } });
        
        if('mediaSession' in navigator) { 
            navigator.mediaSession.metadata = new MediaMetadata({ title: track.title, artist: displayArtist, artwork: [{ src: hqImg, sizes: '512x512', type: 'image/jpeg' }] }); 
            navigator.mediaSession.setActionHandler('play', togglePlay); 
            navigator.mediaSession.setActionHandler('pause', togglePlay); 
            navigator.mediaSession.setActionHandler('previoustrack', playPrev); 
            navigator.mediaSession.setActionHandler('nexttrack', playNext);
            navigator.mediaSession.setActionHandler('seekto', (details) => {
                if (details.fastSeek && 'fastSeek' in audio) { audio.fastSeek(details.seekTime); return; }
                audio.currentTime = details.seekTime;
                updateMediaSessionPosition();
            });
        }
    }
    function refreshCurrentListView() { 
        document.querySelectorAll('.list-info h4').forEach(t => t.classList.remove('text-green'));
        document.querySelectorAll('.list-item').forEach(el => el.classList.remove('buffering'));

        if(document.getElementById('album-view').classList.contains('active') && state.currentAlbumData) {
            renderAlbumTracks(state.currentAlbumData.songs, state.currentAlbumData.img);
        }
        
        if(document.getElementById('library-view').classList.contains('active') || !document.getElementById('library-view').classList.contains('hidden')) {
             if(state.bufferingId) {
                 // Library view refreshes handled by filter switch or re-render mostly.
             }
        }
    }
    
    function initAudioContext() {
    if (audioCtx) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    audioSource = audioCtx.createMediaElementSource(audio);

    // 1. Create Enhancement Nodes
    preGainNode = audioCtx.createGain();
    preGainNode.gain.value = 1.0; 

    // 8D Audio Nodes
    pannerNode = new StereoPannerNode(audioCtx, { pan: 0 }); 
    filterNode = audioCtx.createBiquadFilter(); // Muffler for 8D
    filterNode.type = 'lowpass';
    filterNode.frequency.value = 20000;
    
    gainNode8D = audioCtx.createGain(); // Distance volume for 8D
    gainNode8D.gain.value = 1.0;

    // Bass Booster / Limiter (Prevents distortion on high volume)
    compressorNode = audioCtx.createDynamicsCompressor(); 
    compressorNode.threshold.value = -6; 
    compressorNode.knee.value = 0; 
    compressorNode.ratio.value = 20; 
    compressorNode.attack.value = 0.001; 
    compressorNode.release.value = 0.1;

    // 2. Connect the Chain: 
    // Source -> PreGain -> EQ -> Gain8D -> Filter -> Panner -> Compressor -> Output
    audioSource.connect(preGainNode);
    let prevNode = preGainNode;

    eqBands = [];
    djFrequencies.forEach((freq, index) => {
        const filter = audioCtx.createBiquadFilter();
        filter.frequency.value = freq;
        // Use shelving for bass/treble, peaking for mids
        if (index <= 1) filter.type = 'lowshelf'; 
        else if (index === djFrequencies.length - 1) filter.type = 'highshelf';
        else { filter.type = 'peaking'; filter.Q.value = 1.4; }
        
        filter.gain.value = eqPresets[eqMode][index] || 0;
        
        prevNode.connect(filter);
        prevNode = filter;
        eqBands.push(filter);
    });

    // Complete connections
    prevNode.connect(gainNode8D);
    gainNode8D.connect(filterNode);
    filterNode.connect(pannerNode);
    pannerNode.connect(compressorNode);
    compressorNode.connect(audioCtx.destination);
}
    function cycleEqMode() {
    if(!audioCtx) initAudioContext();
    if(audioCtx.state === 'suspended') audioCtx.resume();

    // 1. Change Mode
    eqMode = (eqMode + 1) % 4;
    
    const modes = ["Normal", "Bass Boost", "Enhanced", "8D Audio"];
    
    // 2. Update Buttons UI
    const btn = document.getElementById('dj-btn');
    btn.className = 'dj-btn'; 
    if(eqMode === 1) btn.classList.add('mode-bass');
    if(eqMode === 2) btn.classList.add('mode-enhanced');
    if(eqMode === 3) btn.classList.add('mode-8d');
    
    showToast(`Mode: ${modes[eqMode]}`);

    // 3. Apply EQ Gains
    const now = audioCtx.currentTime;
    const gains = eqPresets[eqMode];
    eqBands.forEach((band, i) => {
        const val = gains[i] || 0;
        if(band.gain.setTargetAtTime) band.gain.setTargetAtTime(val, now, 0.1);
        else band.gain.value = val;
    });

    // 4. Handle 8D Animation Logic
    const preGains = [1.0, 0.6, 0.8, 0.9]; // Lower volume for Bass Boost to prevent clipping
    const targetPreGain = preGains[eqMode];
    
    if(preGainNode.gain.setTargetAtTime) preGainNode.gain.setTargetAtTime(targetPreGain, now, 0.1);
    else preGainNode.gain.value = targetPreGain;

    // Reset previous animation
    if(pannerInterval) cancelAnimationFrame(pannerInterval);

    if(eqMode === 3) {
        // --- 8D ANIMATION START ---
        const start8D = () => {
            // Speed of rotation (3500ms)
            const t = Date.now() / 3500; 
            
            // Rotate Left/Right
            const x = Math.sin(t);
            pannerNode.pan.value = x * 0.9; 
            
            // Muffle sound when "behind" head
            const freq = (Math.cos(t) < 0) ? 8000 : 18000;
            filterNode.frequency.value = filterNode.frequency.value * 0.95 + freq * 0.05; 
            
            // Distance volume change
            const distGain = 0.9 + (0.1 * Math.abs(Math.cos(t)));
            gainNode8D.gain.value = distGain;
            
            pannerInterval = requestAnimationFrame(start8D);
        };
        start8D();
    } else {
        // --- RESET TO NORMAL ---
        pannerNode.pan.value = 0;
        filterNode.frequency.value = 20000;
        gainNode8D.gain.value = 1.0;
    }
}
    function setupGestures() { const fp = document.getElementById('full-player'); let lastTap = 0; fp.addEventListener('click', (e) => { if(e.target.closest('button') || e.target.closest('input') || e.target.closest('.fp-menu-overlay') || e.target.closest('#mini-lyrics-player') || e.target.closest('.yt-controls') || e.target.closest('.shield')) return; const now = Date.now(); if(now - lastTap < 300) { const vid = document.getElementById('canvas-video'); const isVideoReady = state.showCanvas && vid.src && vid.src !== "" && vid.style.opacity !== '0' && !state.videoMode; if (isVideoReady) { fp.classList.toggle('canvas-immersive'); } else if(!state.videoMode) { showToast("Immersive mode unavailable (No Video)"); } } lastTap = now; }); }
    function setupLongPress(el, callback) { let timer; const start = () => timer = setTimeout(callback, 800); const end = () => clearTimeout(timer); el.addEventListener('touchstart', start); el.addEventListener('touchend', end); el.addEventListener('touchmove', end); el.addEventListener('mousedown', start); el.addEventListener('mouseup', end); }

    function updateProgress() { 
        if(state.videoMode) return;
        const pct = (audio.currentTime / audio.duration) * 100; document.getElementById('mp-progress').style.width = pct + '%'; const slider = document.getElementById('seek-slider'); if(!slider.matches(':active')) { slider.value = audio.currentTime; slider.style.backgroundSize = `${pct}% 100%`; } document.getElementById('curr-time').innerText = fmtTime(audio.currentTime); document.getElementById('imm-fill').style.width = pct + '%'; document.getElementById('imm-curr').innerText = fmtTime(audio.currentTime); document.getElementById('imm-total').innerText = fmtTime(audio.duration); 
    }
    function updateIcons() { const cls = state.isPlaying ? 'fa-pause' : 'fa-play'; document.getElementById('mini-play-icon').className = `fas ${cls}`; document.getElementById('fp-play-icon').className = `fas ${cls}`; }
    
    function playNext() { if(state.isShuffle) state.qIndex = Math.floor(Math.random() * state.queue.length); else if(state.qIndex < state.queue.length - 1) state.qIndex++; else state.qIndex = 0; loadAndPlay(); }
    function playPrev() { 
        let cTime = state.videoMode && ytPlayer ? ytPlayer.getCurrentTime() : audio.currentTime;
        if(cTime > 3) {
            if(state.videoMode) {
                 if(state.isDirectVideo) document.getElementById('direct-video-player').currentTime = 0;
                 else if(ytPlayer) ytPlayer.seekTo(0, true);
            }
            else audio.currentTime = 0;
        } else { 
            if(state.qIndex > 0) state.qIndex--; else state.qIndex = state.queue.length - 1; loadAndPlay(); 
        } 
    }
    function togglePlay() { 
        // 1. Strict Video Mode Check
        if (state.videoMode) {
            if(state.isDirectVideo) {
                const dv = document.getElementById('direct-video-player');
                if (dv.paused) dv.play(); else dv.pause();
                showYTControls();
            } else if (ytPlayer && ytPlayer.getPlayerState) {
                const s = ytPlayer.getPlayerState();
                if (s === YT.PlayerState.PLAYING || s === YT.PlayerState.BUFFERING) {
                    ytPlayer.pauseVideo();
                } else {
                    ytPlayer.playVideo();
                }
            }
            return;
        }

        // 2. Audio Mode Logic
        if(audio.paused) audio.play(); else audio.pause(); 
    }
    
    function toggleShuffle() { state.isShuffle = !state.isShuffle; if(state.isShuffle) state.isLoop = false; document.getElementById('btn-shuffle').classList.toggle('active-ctrl', state.isShuffle); document.getElementById('btn-loop').classList.toggle('active-ctrl', state.isLoop); }
    function toggleLoop() { state.isLoop = !state.isLoop; if(state.isLoop) state.isShuffle = false; document.getElementById('btn-loop').classList.toggle('active-ctrl', state.isLoop); document.getElementById('btn-shuffle').classList.toggle('active-ctrl', state.isShuffle); }
    function toggleLike() { const track = state.queue[state.qIndex]; if(!track) return; const idx = likedSongs.findIndex(s => s.id === track.id); if(idx > -1) likedSongs.splice(idx, 1); else likedSongs.push(track); IdbHelper.set('vibeLiked', likedSongs); updateUI(track); }
    function fmtTime(s) { if(isNaN(s)) return '0:00'; const m = Math.floor(s/60); const sec = Math.floor(s%60); return `${m}:${sec<10?'0'+sec:sec}`; }
    function handleClick(item, showLogo) { if(item.type === 'song') playSong(null, item.link); else openCollection(item.type, item.link, { title: item.title, img: item.img, subtitle: item.type }, false, showLogo); }
    
    // --- CACHING & FAST LOAD ---
    async function checkCache(key) { const res = await IdbHelper.get(key); if(res && (Date.now() - res.ts < 86400000)) return res.data; return null; }
    function saveCache(key, data) { IdbHelper.set(key, { ts: Date.now(), data: data }); }

async function openCollection(type, url, preData, isOffline = false, forceLogo = false) {
        document.getElementById('full-player').classList.remove('active');
        const thisRequestId = ++globalLoadRequestId;
        history.pushState({view: 'album'}, null, '');
        const view = document.getElementById('album-view'); view.classList.add('active');
        
        // --- RESET UI STATES ---
        // Load the provided image (usually 500 from card, or 150 from list)
        document.getElementById('album-art').src = preData.img
    .replace('150x150', '500x500')
    .replace('50x50', '500x500')
    .replace('250x250', '500x500'); 
        const wm = document.getElementById('album-watermark'); 
        
        const isSaved = savedPlaylists.some(p => p.title === preData.title);
        if(forceLogo || isOffline || isSaved) wm.classList.add('show'); else wm.classList.remove('show');
        
        document.getElementById('album-title').innerText = decodeStr(preData.title);
        document.getElementById('album-subtitle').innerText = decodeStr(preData.subtitle);
        document.getElementById('album-meta').innerText = "Loading details...";
        document.getElementById('album-tracks').innerHTML = '<div class="loader"></div>';
        
        const downBtn = document.getElementById('btn-download-album');
        const saveBtn = document.getElementById('btn-save-album');
        downBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
        downBtn.className = "btn-action btn-primary";
        downBtn.onclick = null;
        saveBtn.style.display = 'none';

        state.currentAlbumData = { id: url, title: preData.title, img: preData.img, subtitle: preData.subtitle, songs: [], type: type };

        updateDownloadBtnUI(state.currentAlbumData);

        let songs = [];
        
        try {
            if (isOffline) {
                state.currentAlbumData = preData; songs = preData.songs;
                let totalSec = songs.reduce((acc, s) => acc + (parseInt(s.duration || s.rawData?.duration || 0)), 0);
                let hrs = Math.floor(totalSec / 3600); let mins = Math.floor((totalSec % 3600) / 60);
                document.getElementById('album-meta').innerText = `${songs.length} Songs  ${hrs > 0 ? `${hrs} hr ` : ''}${mins} min`;
                renderAlbumTracks(songs, preData.img);
                updateDownloadBtnUI(state.currentAlbumData);
            } else {
                if(!url) throw new Error("Missing URL");
                let fetchUrl = url; if(url.indexOf('http') !== 0) fetchUrl = `https://www.jiosaavn.com${url}`;
                
                const cacheKey = `cache_collection_${preData.title}_${type}`;
                const cached = await checkCache(cacheKey);

                if (cached) {
                    state.currentAlbumData = cached;
                    songs = cached.songs;
                    let totalSec = songs.reduce((acc, s) => acc + (parseInt(s.rawData?.duration || 0)), 0);
                    let hrs = Math.floor(totalSec / 3600); let mins = Math.floor((totalSec % 3600) / 60);
                    document.getElementById('album-meta').innerText = `${songs.length} Songs  ${hrs > 0 ? `${hrs} hr ` : ''}${mins} min`;
                    if (cached.subtitle) document.getElementById('album-subtitle').innerText = decodeStr(cached.subtitle);
                    renderAlbumTracks(songs, preData.img);
                    updateDownloadBtnUI(state.currentAlbumData);
                }

                if (!cached || (Date.now() - cached.ts > 3600000)) { 
                    let apiEndpoint = '';
                    if (type === 'playlist') {
                        // Page 1, Limit 5
                        apiEndpoint = `${BASE_API}/playlists?link=${encodeURIComponent(fetchUrl)}&page=1&limit=10`;
                    } else {
                        apiEndpoint = `${BASE_API}/albums?link=${encodeURIComponent(fetchUrl)}`;
                    }

                const res = await fetch(apiEndpoint);
                    if (thisRequestId !== globalLoadRequestId) return;
                    
                    const json = await res.json();
                    const data = json.data || json;
                    songs = data.songs || data.list || [];
                    const year = data.year || "";
                    const artists = getArtistName(data);
                    
                    if(artists && artists !== "Unknown Artist") document.getElementById('album-subtitle').innerText = decodeStr(artists);
                    else if (data.description) document.getElementById('album-subtitle').innerText = decodeStr(data.description);
                    if(!songs.length && data.media_url) songs = [data];

                    // Process initial batch using size 150
                    const formattedSongs = songs.map(s => {
                        let sImg = extractImg(s.image, '50'); // <-- REQUEST 150 HERE
                        if(!sImg || sImg.includes('placeholder')) sImg = preData.img;
                        let dUrl = s.downloadUrl; if (!dUrl && s.media_url) { dUrl = [{ link: s.media_url, quality: "320kbps" }]; }
                        return { id: s.id, title: decodeStr(s.name || s.title || s.song), artist: decodeStr(getArtistName(s)), img: sImg, mediaUrl: s.media_url, downloadUrl: dUrl, url: s.url, rawData: s };
                    });

                    state.currentAlbumData = { id: url, title: preData.title, img: preData.img, subtitle: document.getElementById('album-subtitle').innerText, songs: formattedSongs, type: type };
                    saveCache(cacheKey, state.currentAlbumData);

                    if (thisRequestId === globalLoadRequestId) {
                        // Calculate initial duration
                        let totalSec = formattedSongs.reduce((acc, s) => acc + (parseInt(s.rawData.duration || 0)), 0);
                        let hrs = Math.floor(totalSec / 3600); let mins = Math.floor((totalSec % 3600) / 60);
                        
                        let metaText = `${formattedSongs.length} Songs`;
                        // Show duration immediately for what we have
                        metaText += `  ${hrs > 0 ? `${hrs} hr ` : ''}${mins} min`;

                        document.getElementById('album-meta').innerText = metaText;

                        renderAlbumTracks(state.currentAlbumData.songs, preData.img);
                        updateDownloadBtnUI(state.currentAlbumData);
                        
                        if(type === 'playlist') {
                            fetchPlaylistInPackets(fetchUrl, preData.img, cacheKey, thisRequestId);
                        }
                    }
                }
            }
        } catch(e) {
            console.error("Album load error:", e);
            if (thisRequestId === globalLoadRequestId) {
                document.getElementById('album-tracks').innerHTML = '<div style="text-align:center; padding:20px; color:#666;">Failed to load tracks.</div>';
                document.getElementById('album-meta').innerText = "Error";
                showToast("Failed to load content");
            }
        }
    }
 async function fetchPlaylistInPackets(url, fallbackImg, cacheKey, requestId) {
        let page = 2; 
        let hasMore = true;
        const container = document.getElementById('album-tracks');

        while(hasMore) {
            if (requestId !== globalLoadRequestId) break;

            try {
                const apiUrl = `${BASE_API}/playlists?link=${encodeURIComponent(url)}&page=${page}&limit=10`;
                const res = await fetch(apiUrl);
                const json = await res.json();
                const data = json.data || json;
                const rawSongs = data.songs || data.list || [];

                if (!rawSongs || rawSongs.length === 0) {
                    hasMore = false;
                    break;
                }

                const newSongs = [];
                const existingCount = state.currentAlbumData.songs.length;

                rawSongs.forEach((s, i) => {
                    if (state.currentAlbumData.songs.some(ex => ex.id === s.id)) return;

                    let sImg = extractImg(s.image, '50'); // <-- REQUEST 150 HERE
                    if(!sImg || sImg.includes('placeholder')) sImg = fallbackImg;
                    let dUrl = s.downloadUrl; if (!dUrl && s.media_url) { dUrl = [{ link: s.media_url, quality: "320kbps" }]; }
                    
                    const newSongObj = { 
                        id: s.id, 
                        title: decodeStr(s.name || s.title || s.song), 
                        artist: decodeStr(getArtistName(s)), 
                        img: sImg, 
                        mediaUrl: s.media_url, 
                        downloadUrl: dUrl, 
                        url: s.url, 
                        rawData: s 
                    };
                    newSongs.push(newSongObj);

                    const totalIdx = existingCount + i;
                    const div = document.createElement('div'); div.className = 'list-item';
                    
                    const isPlaying = state.currentTrackId === newSongObj.id;
                    
                    div.innerHTML = `
                        <span style="width:20px;text-align:center;color:#666;font-size:12px;margin-right:10px;">${totalIdx+1}</span>
                        <div style="position:relative"><img src="${newSongObj.img}"><div class="buffering-overlay"><div class="buf-spinner"></div></div></div>
                        <div class="list-info">
                            <div class="marquee-container"><h4 class="marquee-content ${isPlaying?'text-green':''}">${newSongObj.title}</h4></div>
                            <div class="marquee-container"><p class="marquee-content">${newSongObj.artist}</p></div>
                        </div>`;
                        
                    div.onclick = () => { 
                        state.queue = state.currentAlbumData.songs; 
                        state.qIndex = totalIdx; 
                        loadAndPlay(); 
                    };
                    
                    container.appendChild(div);
                });

                if (newSongs.length > 0) {
                    state.currentAlbumData.songs.push(...newSongs);
                    saveCache(cacheKey, state.currentAlbumData);

                    // --- REAL-TIME DURATION CALCULATION ---
                    let totalSec = state.currentAlbumData.songs.reduce((acc, s) => acc + (parseInt(s.rawData.duration || 0)), 0);
                    let hrs = Math.floor(totalSec / 3600); 
                    let mins = Math.floor((totalSec % 3600) / 60);
                    
                    document.getElementById('album-meta').innerText = `${state.currentAlbumData.songs.length} Songs  ${hrs > 0 ? `${hrs} hr ` : ''}${mins} min`;
                    // --------------------------------------

                    window.observeMarquees();
                    page++; 
                } else {
                    hasMore = false;
                }

            } catch (e) {
                console.log("Packet fetch stopped", e);
                hasMore = false;
            }
        }
    }
    function renderAlbumTracks(songs, fallbackImg) {
        const container = document.getElementById('album-tracks'); container.innerHTML = '';
        if(!songs || !songs.length) { container.innerHTML = '<div style="text-align:center; padding:20px; color:#666;">No songs found</div>'; return; }
        songs.forEach((s, i) => {
            const isPlaying = state.currentTrackId === s.id;
            const isBuffering = state.bufferingId === s.id;
            const div = document.createElement('div'); div.className = `list-item ${isBuffering ? 'buffering' : ''}`;
            const bufferingHtml = `<div class="buffering-overlay"><div class="buf-spinner"></div></div>`;
            div.innerHTML = `<span style="width:20px;text-align:center;color:#666;font-size:12px;margin-right:10px;">${i+1}</span><div style="position:relative"><img src="${s.img || fallbackImg}">${bufferingHtml}</div><div class="list-info"><div class="marquee-container"><h4 class="marquee-content ${isPlaying?'text-green':''}">${decodeStr(s.title)}</h4></div><div class="marquee-container"><p class="marquee-content">${decodeStr(s.artist)}</p></div></div>`;
            div.onclick = () => { state.queue = songs; state.qIndex = i; loadAndPlay(); };
            container.appendChild(div);
        }); window.observeMarquees();
    }
    
    // --- ARTIST VIEW IMPLEMENTATION ---
    async function openArtist(id) {
        document.getElementById('full-player').classList.remove('active');
        history.pushState({view: 'artist'}, null, '');
        const view = document.getElementById('artist-view'); view.classList.add('active');
        document.getElementById('artist-name').innerText = "Loading...";
        document.getElementById('artist-role').innerText = "";
        document.getElementById('artist-stats').innerText = "";
        document.getElementById('artist-img').src = "https://via.placeholder.com/150";
        document.getElementById('artist-songs').innerHTML = '<div class="loader"></div>';
        document.getElementById('artist-albums').innerHTML = '<div class="loader"></div>';

        try {
            const [detailsRes, songsRes, albumsRes] = await Promise.all([
                fetch(`${BASE_API}/artists/${id}`),
                fetch(`${BASE_API}/artists/${id}/songs`),
                fetch(`${BASE_API}/artists/${id}/albums`)
            ]);

            const details = await detailsRes.json();
            const songData = await songsRes.json();
            const albumData = await albumsRes.json();

            const d = details.data;
            document.getElementById('artist-name').innerText = decodeStr(d.name);
            document.getElementById('artist-role').innerText = decodeStr(d.dominantType || "Artist");
            document.getElementById('artist-stats').innerText = `${(d.fanCount || 0).toLocaleString()} Fans  ${d.followerCount ? d.followerCount.toLocaleString() : 0} Followers`;
            document.getElementById('artist-img').src = extractImg(d.image);

            const songsEl = document.getElementById('artist-songs'); songsEl.innerHTML = '';
            const songs = (songData.data.songs || songData.data || []).map(s => ({
                id: s.id,
                title: decodeStr(s.name || s.title),
                artist: getArtistName(s),
                img: extractImg(s.image),
                downloadUrl: s.downloadUrl,
                url: s.url,
                rawData: s
            }));

            songs.forEach((s, i) => {
                const div = document.createElement('div'); div.className = 'list-item';
                div.innerHTML = `<span style="width:20px;text-align:center;color:#666;font-size:12px;margin-right:10px;">${i+1}</span><img src="${s.img}"><div class="list-info"><div class="marquee-container"><h4 class="marquee-content">${s.title}</h4></div><p>${s.artist}</p></div>`;
                div.onclick = () => { state.queue = songs; state.qIndex = i; loadAndPlay(); };
                songsEl.appendChild(div);
            });

            const albumsEl = document.getElementById('artist-albums'); albumsEl.innerHTML = '';
            const albums = (albumData.data.albums || albumData.data || []);
            
            albums.forEach(a => {
                const div = document.createElement('div'); div.className = 'card';
                const img = extractImg(a.image);
                const title = decodeStr(a.name || a.title);
                const albumUrl = a.perma_url || a.url || "";
                div.innerHTML = `<img src="${img}"><div class="marquee-container"><h3 class="marquee-content">${title}</h3></div><p>${a.year || 'Album'}</p>`;
                div.onclick = () => openCollection('album', albumUrl, { title, img, subtitle: 'Album' });
                albumsEl.appendChild(div);
            });
            window.observeMarquees();

        } catch(e) { console.error(e); showToast("Error loading artist data"); }
    }

    // --- MODAL LOGIC ---
    let pendingDeleteAction = null;
    function openModal(action) { pendingDeleteAction = action; document.getElementById('confirm-modal').classList.add('active'); }
    function closeModal() { pendingDeleteAction = null; document.getElementById('confirm-modal').classList.remove('active'); }
    document.getElementById('modal-yes-btn').addEventListener('click', () => { if(pendingDeleteAction) pendingDeleteAction(); closeModal(); });

    // --- FULL PLAYER MENU LOGIC ---
async function toggleFpMenu() { 
        const overlay = document.getElementById('fp-menu-overlay');
        const isActive = overlay.classList.contains('active');
        
        // 1. Toggle the menu logic inside a try-catch block to prevent crashing
        try {
            if (!isActive) {
                const track = state.queue[state.qIndex];
                const injection = document.getElementById('song-details-injection');
                injection.innerHTML = '';
                
                // Video Switch Button
                const vidSwitchContainer = document.getElementById('video-switch-btn');
                const icon = state.videoMode ? 'fa-music' : 'fa-film';
                const text = state.videoMode ? 'Switch to Audio' : 'Switch to Video';
                vidSwitchContainer.innerHTML = `<div class="fp-menu-item" onclick="toggleFpMenu(); toggleVideoMode()"><i class="fas ${icon}"></i><span>${text}</span></div>`;

                const isDownloaded = downloads.some(d => d.id === track.id);
                const menuDownBtn = document.getElementById('menu-download-btn');
                if(isDownloaded) {
                    menuDownBtn.innerHTML = '<i class="fas fa-trash"></i><span>Delete Song</span>';
                    menuDownBtn.onclick = () => { toggleFpMenu(); deleteItem({ id: track.id, from: 'downloaded' }); };
                } else {
                    menuDownBtn.innerHTML = '<i class="fas fa-download"></i><span>Download Song</span>';
                    menuDownBtn.onclick = downloadCurrentSongAction;
                }

                if (track) {
                    const raw = track.rawData || {};
                    let metaHtml = '<div class="song-meta-grid">';
                    if(raw.year || raw.releaseDate) metaHtml += `<div class="meta-item"><span class="meta-label">Released</span><span class="meta-val">${raw.year || raw.releaseDate}</span></div>`;
                    if(raw.label) metaHtml += `<div class="meta-item"><span class="meta-label">Label</span><span class="meta-val">${raw.label}</span></div>`;
                    if(raw.copyright_text || raw.copyright) metaHtml += `<div class="meta-item"><span class="meta-label">Copyright</span><span class="meta-val">${raw.copyright_text || raw.copyright}</span></div>`;
                    if(raw.duration) metaHtml += `<div class="meta-item"><span class="meta-label">Duration</span><span class="meta-val">${fmtTime(raw.duration)}</span></div>`;
                    metaHtml += '</div>';

                    let artistsHtml = ''; 
                    let artistList = [];
                    if (raw.artists && raw.artists.primary) artistList = raw.artists.primary;
                    else if (raw.primary_artists && Array.isArray(raw.primary_artists)) artistList = raw.primary_artists; 
                    
                    if(navigator.onLine && (!artistList.length || !raw.year)) {
                        if(artistList.length === 0 && track.artist) {
                            // SAFEGUARD: Ensure track.artist is a string
                            const names = String(track.artist || "").split(', ');
                            names.forEach(name => {
                                 artistsHtml += `<div class="detail-row"><img src="https://via.placeholder.com/50?text=${name.charAt(0)}" class="detail-img"><div class="detail-info"><div class="detail-name">${name}</div><div class="detail-sub">Artist</div></div></div>`;
                            });
                        }
                    }

                    if (artistList.length > 0) {
                        artistList.forEach(a => { artistsHtml += `<div class="detail-row" onclick="toggleFpMenu(); openArtist('${a.id}');"><img src="${extractImg(a.image)}" class="detail-img"><div class="detail-info"><div class="detail-name">${a.name}</div><div class="detail-sub">${a.role || 'Artist'}</div></div><div class="detail-link">VIEW</div></div>`; });
                    } else if (!artistsHtml && raw.primary_artists_id && typeof raw.primary_artists_id === 'string') {
                             // SAFEGUARD: Force .toString() to prevent .split crash
                             const ids = raw.primary_artists_id.split(',').map(s=>s.trim());
                             const sourceNames = raw.primary_artists || track.artist || "Artist";
                             const names = String(sourceNames).split(',').map(s=>s.trim());
                             
                             ids.forEach((id, idx) => { 
                                 const name = names[idx] || "Artist"; 
                                 // SAFEGUARD: Escape single quotes in ID to prevent HTML syntax error
                                 const safeId = id.replace(/'/g, "\\'");
                                 artistsHtml += `<div class="detail-row" onclick="toggleFpMenu(); openArtist('${safeId}');"><img src="https://via.placeholder.com/50?text=${name.charAt(0)}" class="detail-img" id="art-img-${id}"><div class="detail-info"><div class="detail-name">${name}</div><div class="detail-sub">Artist</div></div><div class="detail-link">VIEW</div></div>`; 
                                 fetchArtistImage(id); 
                             });
                    }

                    let albumHtml = '';
                    let albName = raw.album && typeof raw.album === 'object' ? raw.album.name : raw.album;
                    let albUrl = raw.album && typeof raw.album === 'object' ? (raw.album.url || raw.album.link) : (raw.album_url || raw.perma_url);
                    if (albName && albUrl) { 
                        // SAFEGUARD: Escape single quotes in Title
                        const safeTitle = albName.replace(/'/g, "\\'");
                        albumHtml = `<div class="detail-row" onclick="toggleFpMenu(); openCollection('album', '${albUrl}', {title: '${safeTitle}', img: '${track.img}', subtitle: 'Album'});"><img src="${track.img}" class="detail-img" style="border-radius:4px;"><div class="detail-info"><div class="detail-name">${albName}</div><div class="detail-sub">Album</div></div><div class="detail-link">OPEN</div></div>`; 
                    }
                    injection.innerHTML = `<div class="song-details-card">${artistsHtml}${albumHtml}</div>${metaHtml}`;
                }
            }
        } catch (error) {
            console.error("Menu population failed", error);
            // Even if data fails, we allow the menu to open so the user isn't stuck
        }

        // 2. Perform the toggle AFTER logic (or despite errors)
        overlay.classList.toggle('active'); 
    }

    async function fetchArtistImage(id) {
        try { const res = await fetch(`${BASE_API}/artists/${id}`); const json = await res.json(); if(json.data && json.data.image) { const img = extractImg(json.data.image); const el = document.getElementById(`art-img-${id}`); if(el) el.src = img; } } catch(e) {}
    }
    
    // --- REAL DOWNLOAD IMPLEMENTATION ---

    async function downloadCurrentSongAction() {
        toggleFpMenu();
        const track = state.queue[state.qIndex]; if(!track) return;
        if(downloads.some(d => d.id === track.id)) { showToast("Already Downloaded"); return; }
        showToast("Downloading Song...");
        
        // --- START FIX: Create HQ Copy for Saving ---
        const trackToSave = JSON.parse(JSON.stringify(track)); // Clone it so we don't disturb UI
        if(trackToSave.img) {
            // Force 500x500
            trackToSave.img = trackToSave.img.replace(/150x150|50x50|250x250/g, '500x500');
        }
        // --- END FIX ---

        try {
            await processDownload(trackToSave); // Download using HQ data
            downloads.push(trackToSave);        // Save HQ data to DB
            await IdbHelper.set('vibeDownloads', downloads);
            showToast("Song Downloaded");
        } catch(e) { showToast("Download Failed"); console.error(e); }
    }

    function updateDownloadBtnUI(albumData) {
        const btn = document.getElementById('btn-download-album');
        const saveBtn = document.getElementById('btn-save-album');
        
        if (!albumData) return;
        
        const isDownloaded = offlinePlaylists.some(p => p.id === albumData.id); 
        const isSaved = savedPlaylists.some(p => p.title === albumData.title); 
        const typeText = albumData.type === 'album' ? 'Album' : 'Playlist';

        if (isDownloaded) {
            btn.innerHTML = `<i class="fas fa-check-circle"></i> Downloaded`;
            btn.className = "btn-action btn-secondary";
            btn.onclick = null;
            saveBtn.style.display = 'none'; 
        } else if (state.downloadState.active && state.downloadState.id === albumData.id) {
            btn.innerHTML = `Downloading ${state.downloadState.current}/${state.downloadState.total} | Cancel`;
            btn.className = "btn-action btn-primary";
            btn.onclick = cancelDownload;
            saveBtn.style.display = 'none';
        } else {
            btn.innerHTML = `<i class="fas fa-download"></i> Download ${typeText}`;
            btn.className = "btn-action btn-primary";
            btn.onclick = downloadPlaylistAction;
            
            if(isSaved) {
                 saveBtn.innerHTML = `<i class="fas fa-check"></i> Saved`;
                 saveBtn.onclick = null; 
                 saveBtn.style.display = 'flex';
            } else {
                 saveBtn.innerHTML = `<i class="fas fa-bookmark"></i> Save`;
                 saveBtn.onclick = savePlaylistView;
                 saveBtn.style.display = 'flex';
            }
        }
    }

    async function processDownload(track) {
        let src = null;
        if(track.downloadUrl) {
             if(Array.isArray(track.downloadUrl)) { const found = track.downloadUrl.find(x => x.quality === state.quality) || track.downloadUrl[track.downloadUrl.length-1]; src = found.url || found.link; }
             else src = track.downloadUrl;
        } else if (track.mediaUrl) src = track.mediaUrl;

        if (!src) throw new Error("No URL");

        const audioBlob = await fetchBlob(src);
        await IdbHelper.set(`blob_audio_${track.id}_${state.quality}`, audioBlob);
        
        await fetchMeta(track.title, track.artist, track.id, state.metaFetchId);
        if(metaCache[track.id]) { metaCache[track.id].permanent = true; await IdbHelper.set('vibeMetaCache', metaCache); }
    }

    async function downloadPlaylistAction() {
        if(!state.currentAlbumData) return;
        if(state.downloadState.active) return;
        
        // DEEP COPY SNAPSHOT of the album data to fix the bug where navigating away changes what gets saved
        const albumSnapshot = JSON.parse(JSON.stringify(state.currentAlbumData));
        const songs = albumSnapshot.songs;
        
        if (!songs || songs.length === 0) return;

        state.downloadState = { active: true, id: albumSnapshot.id, total: songs.length, current: 0, abort: new AbortController() };
        updateDownloadBtnUI(state.currentAlbumData); // UI Update for current view if matches

        try {
            for (let i = 0; i < songs.length; i++) {
                if (state.downloadState.abort.signal.aborted) throw new Error("Cancelled");
                state.downloadState.current = i + 1;
                // Only update UI if user is still looking at the same album
                if(state.currentAlbumData && state.currentAlbumData.id === albumSnapshot.id) {
                    updateDownloadBtnUI(state.currentAlbumData);
                }
                
                if(!downloads.some(d => d.id === songs[i].id)) {
                    await processDownload(songs[i]);
                    downloads.push(songs[i]);
                    await IdbHelper.set('vibeDownloads', downloads);
                }
            }
            
            offlinePlaylists.push(albumSnapshot);
            await IdbHelper.set('vibeOfflinePlaylists', offlinePlaylists);
            
            state.downloadState.active = false;
            
            if(state.currentAlbumData && state.currentAlbumData.id === albumSnapshot.id) {
                updateDownloadBtnUI(state.currentAlbumData);
            }
            showToast("Download Complete");
        } catch(e) {
            console.log(e);
            state.downloadState.active = false;
            if(state.currentAlbumData && state.currentAlbumData.id === albumSnapshot.id) {
                updateDownloadBtnUI(state.currentAlbumData);
            }
            if(e.message === "Cancelled") showToast("Download Cancelled");
            else showToast("Download Failed (Network?)");
        }
    }

    function cancelDownload() {
        if(state.downloadState.abort) state.downloadState.abort.abort();
        state.downloadState.active = false;
        if(state.currentAlbumData) updateDownloadBtnUI(state.currentAlbumData);
    }
    
    function changeQualityFromPlayer(selectEl) {
        state.quality = selectEl.value; localStorage.setItem('vibeQuality', state.quality);
        document.querySelectorAll('.quality-btn').forEach(btn => { if(btn.getAttribute('onclick').includes(state.quality)) btn.classList.add('active'); else btn.classList.remove('active'); });
        showToast(`Quality: ${state.quality}. Plays next.`); toggleFpMenu();
    }

    function showToast(msg) { const t = document.getElementById('toast'); t.innerText = msg; t.style.display='block'; setTimeout(()=>t.style.display='none', 2000); }
    function switchTab(tab) {
        document.querySelectorAll('.nav-item').forEach(e => e.classList.remove('active'));
        const idx = ['home','search','library','settings'].indexOf(tab); if(idx>-1) document.querySelectorAll('.nav-item')[idx].classList.add('active');
        ['home','search','library','settings'].forEach(v => document.getElementById(`${v}-view`).classList.add('hidden'));
        document.getElementById(`${tab}-view`).classList.remove('hidden'); 
        if(tab==='library') {
             switchLibFilter('all', document.querySelector('.filter-chips .filter-chip:first-child'));
        }
    }

    // --- UPDATED LIBRARY UI LOGIC ---

    function createSection(title, items, type) {
        if (!items || items.length === 0) return null;
        const section = document.createElement('div');
        
        const h3 = document.createElement('h3');
        h3.className = 'section-title';
        h3.innerText = title;
        section.appendChild(h3);

        if (type === 'card') {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid-scroll'; 
            items.forEach(item => {
                const div = document.createElement('div'); div.className = 'card lib-item-entry';
                const isOfflinePlaylist = item.from === 'offline' || item.from === 'saved';
                const watermarkHtml = isOfflinePlaylist ? `<img src="${APP_LOGO_URL}" class="watermark-logo">` : '';

                div.innerHTML = `${watermarkHtml}<img src="${item.img}"><div class="marquee-container"><h3 class="marquee-content">${decodeStr(item.title)}</h3></div><p>${item.subtitle || 'Collection'}</p>`;
                div.onclick = () => openCollection(item.type || 'playlist', item.id, item, item.from === 'offline');
                setupLongPress(div, () => openModal(() => deleteItem(item)));
                gridDiv.appendChild(div);
            });
            section.appendChild(gridDiv);
        } else {
            // --- LIST VIEW LOGIC ---
            const listDiv = document.createElement('div');
            listDiv.className = 'list-view';
            items.forEach(item => {
                const div = document.createElement('div'); 
                div.className = 'list-item lib-item-entry'; 
                
                // We keep justify-content, but the inner div needs to fill the space
                div.style.justifyContent = 'space-between';
                
                div.onclick = () => { state.queue = items; state.qIndex = items.indexOf(item); loadAndPlay(); };
                
                const isBuffering = state.bufferingId === item.id;
                if(isBuffering) div.classList.add('buffering');
                const bufferingHtml = `<div class="buffering-overlay"><div class="buf-spinner"></div></div>`;

                // --- CRITICAL CHANGE BELOW ---
                // Added: flex:1; min-width:0; overflow:hidden;
                // This forces the wrapper to clamp to the screen width, triggering the marquee.
                div.innerHTML = `<div style="position:relative; display:flex; flex:1; min-width:0; overflow:hidden; align-items:center;"><img src="${item.img}">${bufferingHtml}<div class="list-info"><div class="marquee-container"><h4 class="marquee-content">${decodeStr(item.title)}</h4></div><div class="marquee-container"><p class="marquee-content">${decodeStr(item.artist || 'Artist')}</p></div></div></div>`;
                
                setupLongPress(div, () => openModal(() => deleteItem(item)));
                listDiv.appendChild(div);
            });
            section.appendChild(listDiv);
        }
        return section;
    }

    function switchLibFilter(filter, el) {
        if (el) {
            document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
            el.classList.add('active');
        }
        
        const content = document.getElementById('lib-content');
        content.innerHTML = '';

        const savedAlbs = savedPlaylists.filter(p => p.type === 'album').map(p => ({...p, from: 'saved', subtitle: 'Saved Album'}));
        const savedPls = savedPlaylists.filter(p => p.type === 'playlist').map(p => ({...p, from: 'saved', subtitle: 'Saved Playlist'}));

        const downAlbs = offlinePlaylists.filter(p => !p.type || p.type === 'album').map(p => ({...p, from: 'offline', subtitle: 'Downloaded Album'}));
        const downPls = offlinePlaylists.filter(p => p.type === 'playlist').map(p => ({...p, from: 'offline', subtitle: 'Downloaded Playlist'}));

        const favSongs = likedSongs.map(s => ({...s, from: 'liked', artist: s.artist || getArtistName(s)}));
        const downSongs = downloads.map(s => ({...s, from: 'downloaded', artist: s.artist || getArtistName(s)}));

        if (filter === 'all') {
            const s1 = createSection("Saved Albums", savedAlbs, 'card'); if(s1) content.appendChild(s1);
            const s2 = createSection("Downloaded Albums", downAlbs, 'card'); if(s2) content.appendChild(s2);
            const s3 = createSection("Saved Playlists", savedPls, 'card'); if(s3) content.appendChild(s3);
            const s4 = createSection("Downloaded Playlists", downPls, 'card'); if(s4) content.appendChild(s4);
            const s5 = createSection("Favourites", favSongs, 'list'); if(s5) content.appendChild(s5);
            const s6 = createSection("Downloaded Songs", downSongs, 'list'); if(s6) content.appendChild(s6);
            if(!content.hasChildNodes()) content.innerHTML = '<div style="text-align:center; padding:50px; color:#666;">Library is empty</div>';
        } 
        else if (filter === 'albums') {
            const s1 = createSection("Saved Albums", savedAlbs, 'card'); if(s1) content.appendChild(s1);
            const s2 = createSection("Downloaded Albums", downAlbs, 'card'); if(s2) content.appendChild(s2);
            if(!content.hasChildNodes()) content.innerHTML = '<div style="text-align:center; padding:50px; color:#666;">No Albums</div>';
        }
        else if (filter === 'playlists') {
            const s3 = createSection("Saved Playlists", savedPls, 'card'); if(s3) content.appendChild(s3);
            const s4 = createSection("Downloaded Playlists", downPls, 'card'); if(s4) content.appendChild(s4);
            if(!content.hasChildNodes()) content.innerHTML = '<div style="text-align:center; padding:50px; color:#666;">No Playlists</div>';
        }
        else if (filter === 'songs') {
            const s5 = createSection("Favourites", favSongs, 'list'); if(s5) content.appendChild(s5);
            const s6 = createSection("Downloaded Songs", downSongs, 'list'); if(s6) content.appendChild(s6);
            if(!content.hasChildNodes()) content.innerHTML = '<div style="text-align:center; padding:50px; color:#666;">No Songs</div>';
        }
        
        window.observeMarquees();
    }

    function deleteItem(item) {
        if (item.from === 'liked') { const idx = likedSongs.findIndex(x=>x.id===item.id); if(idx>-1) likedSongs.splice(idx,1); IdbHelper.set('vibeLiked', likedSongs); }
        else if (item.from === 'saved') { const idx = savedPlaylists.findIndex(x=>x.title===item.title); if(idx>-1) savedPlaylists.splice(idx,1); IdbHelper.set('vibeSavedPlaylists', savedPlaylists); }
        else if (item.from === 'downloaded') { const idx = downloads.findIndex(x=>x.id===item.id); if(idx>-1) downloads.splice(idx,1); IdbHelper.set('vibeDownloads', downloads); IdbHelper.delete(`blob_audio_${item.id}_${state.quality}`); }
        else if (item.from === 'offline') { const idx = offlinePlaylists.findIndex(x=>x.title===item.title); if(idx>-1) offlinePlaylists.splice(idx,1); IdbHelper.set('vibeOfflinePlaylists', offlinePlaylists); }
        
        const activeChip = document.querySelector('.filter-chip.active');
        const filterName = activeChip ? activeChip.innerText.toLowerCase() : 'all';
        switchLibFilter(filterName, null); 
        showToast("Deleted");
    }

    function openFullPlayer() { history.pushState({view: 'player'}, null, ''); document.getElementById('full-player').classList.add('active'); }
    function savePlaylistView() { 
        if(!state.currentAlbumData) return; 
        if(savedPlaylists.some(p => p.title === state.currentAlbumData.title)) { showToast("Already Saved"); return; } 
        state.currentAlbumData.type = state.currentAlbumData.type || 'album';
        savedPlaylists.push(state.currentAlbumData); 
        IdbHelper.set('vibeSavedPlaylists', savedPlaylists).then(() => { showToast("Saved"); updateDownloadBtnUI(state.currentAlbumData); }).catch(() => { showToast("Save Failed"); savedPlaylists.pop(); }); 
    }

    // ================= NEW YOUTUBE LOGIC =================

    async function fetchYouTubeId(songName, artistName, trackId, label) {
        // Use cached YouTube ID if available
        if (metaCache[trackId] && metaCache[trackId].ytId) {
            return metaCache[trackId].ytId;
        }

        // Clean logic
        const clean = (s) => (s || "").toLowerCase().replace(/[^\w\s]/g, " ").replace(/\s+/g, " ").trim();
        const qSong = clean(songName);
        const qArtist = clean(artistName);
        const qLabel = clean(label); 
        
        // Construct Query with Label
        const query = `${qSong} ${qArtist} ${qLabel}`.trim();
        
        let attempts = 0;
        const MAX_RETRIES = 5;

        while(attempts < MAX_RETRIES) {
            try {
                const ytUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}Original full video`;
// DIRECT JINA URL
const directUrl = `https://r.jina.ai/${ytUrl}`; 

const res = await fetch(directUrl);
                if(!res.ok) throw new Error("Proxy error");
                const text = await res.text();

                // Regex to find the first video link
                const regex = /\[([^\]]+)\]\((https:\/\/www\.youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11}))/;
                const match = regex.exec(text);

                // DIRECTLY USE TOP 1ST RESULT
                if (match && match[3]) {
                    let bestId = match[3]; 

                    // Save to cache
                    let cacheEntry = metaCache[trackId] || { ts: Date.now(), permanent: false };
                    cacheEntry.ytId = bestId;
                    metaCache[trackId] = cacheEntry;
                    IdbHelper.set('vibeMetaCache', metaCache);
                    
                    // Only update currentTrackYTId if this fetch corresponds to the current track
                    if (state.currentTrackId === trackId) {
                        state.currentTrackYTId = bestId;
                    }
                    return bestId;
                }
            } catch (e) {
                console.log(`YT Attempt ${attempts+1} failed`, e);
            }
            attempts++;
            if(attempts < MAX_RETRIES) await new Promise(r => setTimeout(r, 1000));
        }

        return null; 
    }
    
function toggleVideoMode() {
        if (state.videoSwitching) return;
        state.videoSwitching = true;

        // Snapshot current track ID to prevent race conditions
        const currentTrackWhenClicked = state.currentTrackId;

        // --- NEW LANDSCAPE REFS ---
        const leftPanel = document.querySelector('.fp-left-panel');
        const modeBtns = document.querySelectorAll('.mode-btn');
        const btnArt = document.getElementById('mode-art');
        const btnVid = document.getElementById('mode-vid');

        // --- EXISTING PLAYER REFS ---
        const art = document.getElementById('fp-art');
        const vidContainer = document.getElementById('yt-view-container');
        const canvas = document.getElementById('canvas-video');
        const fullPlayer = document.getElementById('full-player');
        const fpImgArea = document.getElementById('fp-img-area');
        const dv = document.getElementById('direct-video-player');
        const ytLoader = document.getElementById('yt-loader');

        // Hide Mini Lyrics in Portrait while switching
        document.getElementById('mini-lyrics-player').style.display = 'none';

        if (!state.videoMode) {
            // ===========================
            // SWITCHING TO VIDEO MODE
            // ===========================

            // 1. Update Landscape UI Buttons/Panel
            if (modeBtns.length > 0) modeBtns.forEach(b => b.classList.remove('active'));
            if (btnVid) btnVid.classList.add('active');
            if (leftPanel) {
                leftPanel.classList.remove('ratio-art', 'ratio-canvas');
                leftPanel.classList.add('ratio-video');
            }

            // 2. Check if we have a YouTube ID
            if (!state.currentTrackYTId) {
                const t = state.queue[state.qIndex];
                if (!t) { state.videoSwitching = false; return; }
                showToast("Searching Video...");

                fetchYouTubeId(t.title, t.artist, t.id, t.rawData?.label).then(id => {
                    // Check if track changed while searching
                    if (state.currentTrackId !== currentTrackWhenClicked) {
                        state.videoSwitching = false; return;
                    }
                    if (id) {
                        doVideoSwitch(id);
                    } else {
                        showToast("Video not found");
                        // Revert UI if failed
                        if (modeBtns.length > 0) modeBtns.forEach(b => b.classList.remove('active'));
                        if (btnArt) btnArt.classList.add('active');
                        if (leftPanel) {
                            leftPanel.classList.remove('ratio-video', 'ratio-canvas');
                            leftPanel.classList.add('ratio-art');
                        }
                        state.videoSwitching = false;
                    }
                });
                return;
            } else {
                doVideoSwitch(state.currentTrackYTId);
            }

        } else {
            // ===========================
            // SWITCHING BACK TO AUDIO MODE
            // ===========================
            state.videoMode = false;

            // 1. Update Landscape UI (Default back to Art)
            if (modeBtns.length > 0) modeBtns.forEach(b => b.classList.remove('active'));
            if (btnArt) btnArt.classList.add('active');
            if (leftPanel) {
                leftPanel.classList.remove('ratio-video', 'ratio-canvas');
                leftPanel.classList.add('ratio-art');
            }

            // 2. UI Updates
            vidContainer.classList.remove('active');
            art.classList.add('active');
            if (ytLoader) ytLoader.style.display = 'none';

            // 3. STOP DIRECT VIDEO (Fixes Overlap)
            if (state.isDirectVideo) {
                dv.pause();
                dv.removeAttribute('src'); // Remove source completely
                dv.load(); // Force browser to unload media
                dv.style.display = 'none';
                state.isDirectVideo = false;

                // Remove event listeners
                dv.onplay = null;
                dv.onpause = null;
                dv.ontimeupdate = null;
            }

            // 4. Sync Audio Player Duration UI
            if (audio.duration) {
                const mainTotal = document.getElementById('total-time');
                const mainSlider = document.getElementById('seek-slider');
                if (mainTotal) mainTotal.innerText = fmtTime(audio.duration);
                if (mainSlider) mainSlider.max = audio.duration;
            }

            // 5. Sync Time: check where video left off
            let yTime = 0;
            if (state.isDirectVideo) yTime = dv.currentTime;
            else if (ytPlayer && ytPlayer.getCurrentTime) yTime = ytPlayer.getCurrentTime();

            if (audio.duration && yTime >= audio.duration) yTime = 0;
            audio.currentTime = yTime;

            // 6. Resume Audio
            audio.play();

            // 7. Restore Canvas & Lyrics
            if (state.showCanvas) {
                canvas.style.opacity = '1';
                canvas.play().catch(e => {});
            }
            if (state.showLyrics && state.lyricsData) {
                document.getElementById('mini-lyrics-player').style.display = 'block';
            }

            // 8. Destroy Iframe Player
            if (ytPlayer) { try { ytPlayer.destroy(); } catch (e) {} ytPlayer = null; }

            showToast("Switched to Audio");
            state.videoSwitching = false;
        }
    }
    function doVideoSwitch(id) {
        const art = document.getElementById('fp-art');
        const vidContainer = document.getElementById('yt-view-container');
        const canvas = document.getElementById('canvas-video');
        const gradient = document.getElementById('fp-bg-gradient');
        const fullPlayer = document.getElementById('full-player');
        const fpImgArea = document.getElementById('fp-img-area');
        const wrap = document.getElementById('wrap');
        const dv = document.getElementById('direct-video-player');
        
        // Audio Player Elements for Resetting Duration
        const mainSlider = document.getElementById('seek-slider');
        const mainTotal = document.getElementById('total-time');

        // FORCE UI CLEANUP: Hide Mini Lyrics & Canvas
        document.getElementById('mini-lyrics-player').style.display = 'none';

        if (!state.videoMode) {
            // ===========================
            // SWITCHING TO VIDEO MODE
            // ===========================
            state.videoMode = true;
            
            // FIX 1: Force Container Visibility (Overriding Immersive Mode)
            fullPlayer.classList.remove('canvas-immersive');
            fpImgArea.style.opacity = '1';
            fpImgArea.style.pointerEvents = 'auto'; // Ensure clicks work
            
            // Swap Art for Video
            art.classList.remove('active');
            vidContainer.classList.add('active');
            
            // Ensure Gradient stays visible (preserve UI)
            gradient.style.opacity = '1';
            
            // Capture current time to resume
            let resumeTime = audio.currentTime;
            
            // Stop Audio & Canvas
            audio.pause();
            canvas.pause(); 
            canvas.style.opacity = '0';
            
            // RE-APPEND PLAYER CONTAINER IF MISSING (Due to previous destruction)
            if(!document.getElementById('player')) {
                wrap.innerHTML = '<div id="player"></div>';
            }
            dv.style.display = 'none';

            // Load YouTube Video
            ytPlayer = new YT.Player("player", {
            	host: 'https://www.youtube-nocookie.com', 
                videoId: id,
                playerVars: { 
                    autoplay: 1, 
                    controls: 0, 
                    playsinline: 1, 
                    rel: 0, 
                    modestbranding: 1, 
                    iv_load_policy: 3,
                    start: Math.floor(resumeTime),
                    disablekb: 1,
                    fs: 0,
                },
                events: { 
                    onReady: (e) => {
                        e.target.setPlaybackQuality(state.videoQuality);
                        startYTTracker(e, resumeTime, id);
                    }, 
                    onStateChange: onYTStateChange 
                }
            });
            
            showToast("Switched to Video");

        } else {
            // ===========================
            // SWITCHING BACK TO AUDIO
            // ===========================
            state.videoMode = false;
            
            // Swap Video for Art
            vidContainer.classList.remove('active');
            art.classList.add('active');
            
            // Stop Direct Video if active
            if(state.isDirectVideo) {
                dv.pause();
                dv.style.display = 'none';
                dv.src = '';
                state.isDirectVideo = false;
            }

            // FIX 2: Manually Reset Duration UI to Audio values immediately
            if(audio.duration) {
                if(mainTotal) mainTotal.innerText = fmtTime(audio.duration);
                if(mainSlider) mainSlider.max = audio.duration;
            }

            // Sync Time (Audio takes priority, reset if Video was longer)
            let yTime = 0;
            if(state.isDirectVideo) {
                 yTime = dv.currentTime;
            } else if(ytPlayer && ytPlayer.getCurrentTime) {
                yTime = ytPlayer.getCurrentTime();
            }
            
            if (audio.duration && yTime >= audio.duration) {
                yTime = 0; 
            }
            audio.currentTime = yTime;
            
            // Resume Audio
            audio.play();
            
            // Restore Canvas if enabled
            if(state.showCanvas) { 
                canvas.style.opacity = '1'; 
                canvas.play().catch(e=>{}); 
            }
            if(state.showLyrics && state.lyricsData) {
                document.getElementById('mini-lyrics-player').style.display = 'block';
            }
            
            // Destory YT player on switch back
            if(ytPlayer) { try{ ytPlayer.destroy(); }catch(e){} ytPlayer=null; }

            showToast("Switched to Audio");
        }
        state.videoSwitching = false;
    }

    function startYTTracker(event, intendedStartTime, currentVideoId) {
        event.target.playVideo();
        
        let glitchCheckCount = 0;
        let glitchMaxChecks = 40; // Monitor for about 10 seconds total
        let hasReachedTarget = false; // NEW FLAG: Have we successfully jumped to 21s yet?
        
        const tracker = setInterval(() => {
            // Cleanup checks
            if(!state.videoMode || !ytPlayer || !ytPlayer.getDuration || ytDragging) {
                 if(!state.videoMode) clearInterval(tracker);
                 return;
            }
            
            let c = ytPlayer.getCurrentTime();
            let d = ytPlayer.getDuration();
            if(!d) return;
            
            // --- UPDATED AD/GLITCH DETECTION LOGIC ---
            // Only run checks if we are trying to start partway through (e.g., > 5s)
            if (intendedStartTime > 5 && glitchCheckCount < glitchMaxChecks) {
                
                // 1. CHECK: Did we make it to the target time (e.g. 21s)?
                // We give a variance of 5 seconds (e.g. 16s to 26s is acceptable)
                if (!hasReachedTarget) {
                    if (Math.abs(c - intendedStartTime) < 5 || c > intendedStartTime) {
                        hasReachedTarget = true;
                        // console.log("Target reached successfully. Monitoring for fallback reset...");
                    }
                }
                
                // 2. CHECK: If we ALREADY reached target, did we drop back to 0?
                // This captures the "10 -> 00 -> 10 -> 00 (Ad)" scenario
                else if (hasReachedTarget) {
                    if (c < 1.6) {
                        console.log("Ad/Glitch Detected (Reset after seek)! Switching to fallback stream.");
                        clearInterval(tracker);
                        switchToDirectStream(currentVideoId, intendedStartTime);
                        return;
                    }
                }
                
                glitchCheckCount++;
            }
            // ----------------------------------------

            // Update Time Text (0:00 / 3:45)
            const timeEl = document.getElementById('yt-time');
            if(timeEl) timeEl.innerText = fmtTime(c) + " / " + fmtTime(d);

            // Update Progress Bar Width
            const fill = document.getElementById('yt-fill');
            let p = (c / d) * 100;
            if(fill) fill.style.width = p + "%";

            // Sync Play Button Icon
            const playIcon = document.querySelector('#yt-play-btn i');
            if(playIcon) {
                const isPlaying = ytPlayer.getPlayerState() === YT.PlayerState.PLAYING;
                playIcon.className = isPlaying ? 'fas fa-pause' : 'fas fa-play';
            }

            // --- Main Player Sync ---
            const mainSlider = document.getElementById('seek-slider');
            const mainCurr = document.getElementById('curr-time');
            const mainTotal = document.getElementById('total-time');
            
            if(mainSlider && !mainSlider.matches(':active')) {
                mainSlider.max = d;
                mainSlider.value = c;
                mainSlider.style.backgroundSize = `${p}% 100%`;
            }
            if(mainCurr) mainCurr.innerText = fmtTime(c);
            if(mainTotal) mainTotal.innerText = fmtTime(d);
            
            // Loop logic
            if(d - c <= 3 && !ytLooped && state.isLoop) {
                ytLooped = true;
                ytPlayer.seekTo(0, true);
                ytPlayer.playVideo();
                setTimeout(() => ytLooped = false, 1500);
            }
        }, 250);
    }// --- DIRECT STREAM FALLBACK LOGIC ---
    
    async function switchToDirectStream(id, startTime) {
    if(ytPlayer) { try { ytPlayer.destroy(); } catch(e){} ytPlayer = null; }
    
    showToast("Ad detected. Switching player...");
    
    // 1. Show Buffering immediately
    const ytLoader = document.getElementById('yt-loader');
    if(ytLoader) ytLoader.style.display = 'block';

    try {
        const streamUrl = await fetchDirectUrl(id);
        if(!streamUrl) throw new Error("No stream found");
        
        const dv = document.getElementById('direct-video-player');
        
        // 2. Attach Event Listeners for Sync & Buffering
        dv.onwaiting = () => { 
            if(ytLoader) ytLoader.style.display = 'block'; 
        };
        dv.onplaying = () => { 
            if(ytLoader) ytLoader.style.display = 'none';
            state.isPlaying = true;
            updateIcons(); // Syncs Main Play/Pause buttons
        };
        dv.onpause = () => {
            state.isPlaying = false;
            updateIcons(); // Syncs Main Play/Pause buttons
        };
        dv.onplay = () => {
            state.isPlaying = true;
            updateIcons();
        };

        // 3. Set Source and Play
        dv.src = streamUrl;
        dv.style.display = 'block';
        dv.currentTime = startTime;
        
        await dv.play();
        state.isDirectVideo = true;
        
        // Start tracker for Progress Bar
        startDirectVideoTracker();
        
    } catch(e) {
        console.error(e);
        if(ytLoader) ytLoader.style.display = 'none';
        showToast("Video unavailable");
        toggleVideoMode(); // Fallback to audio
    }
}
    
    async function fetchDirectUrl(id) {
        for(const key of YT_STREAM_KEYS) {
            try {
                const url = `https://${YT_STREAM_HOST}/dl?id=${id}&cgeo=IN`;
                const res = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'x-rapidapi-key': key,
                        'x-rapidapi-host': YT_STREAM_HOST
                    }
                });
                
                if(!res.ok) continue; // try next key
                
                const json = await res.json();
                if(json.status !== "OK") continue;
                
                // Filter for 360p MP4
                // Usually represented by itag 18 or specific quality labels
                let formats = json.formats || [];
                if(json.adaptiveFormats) formats = formats.concat(json.adaptiveFormats);
                
                // Priority: 360p with Audio (itag 18) > Any 360p > 480p > Lowest
                let bestFormat = formats.find(f => f.itag === 18); // Standard 360p mp4 with audio
                
                if(!bestFormat) {
                    bestFormat = formats.find(f => (f.qualityLabel === '360p' || f.quality === 'medium') && f.mimeType.includes('mp4'));
                }
                
                if(!bestFormat) {
                     // Fallback to any MP4 with audio
                     bestFormat = formats.find(f => f.mimeType.includes('mp4') && f.audioQuality);
                }
                
                if(bestFormat) return bestFormat.url;
                
            } catch(e) {
                console.log("Key failed", e);
            }
        }
        return null;
    }
    
    function startDirectVideoTracker() {
    const dv = document.getElementById('direct-video-player');
    const ytLoader = document.getElementById('yt-loader');

    const tracker = setInterval(() => {
        // Stop if not in correct mode
        if(!state.videoMode || !state.isDirectVideo) {
            clearInterval(tracker);
            return;
        }
        
        let c = dv.currentTime;
        let d = dv.duration;
        
        // Handle Buffering State (Fallback check)
        if(dv.readyState < 3) {
            if(ytLoader) ytLoader.style.display = 'block';
        } else if (!dv.paused) {
            if(ytLoader) ytLoader.style.display = 'none';
        }

        if(!d) return;

        // UI Updates (Video Controls Overlay)
        const timeEl = document.getElementById('yt-time');
        if(timeEl) timeEl.innerText = fmtTime(c) + " / " + fmtTime(d);

        const fill = document.getElementById('yt-fill');
        let p = (c / d) * 100;
        if(fill) fill.style.width = p + "%";

        // Sync overlay play button
        const playIcon = document.querySelector('#yt-play-btn i');
        if(playIcon) {
            playIcon.className = !dv.paused ? 'fas fa-pause' : 'fas fa-play';
        }
        
        // Sync Main Player (Seek Slider & Time)
        const mainSlider = document.getElementById('seek-slider');
        const mainCurr = document.getElementById('curr-time');
        const mainTotal = document.getElementById('total-time');
        
        if(mainSlider && !mainSlider.matches(':active')) {
            mainSlider.max = d;
            mainSlider.value = c;
            mainSlider.style.backgroundSize = `${p}% 100%`;
        }
        if(mainCurr) mainCurr.innerText = fmtTime(c);
        if(mainTotal) mainTotal.innerText = fmtTime(d);
        
        // Loop Logic
        if(d - c <= 1 && state.isLoop) {
            dv.currentTime = 0;
            dv.play();
        }
        // Auto Next
        if(dv.ended && !state.isLoop) {
             exitFullscreenSafe(); 
playNext();
        }

    }, 250);
}

    function onYTStateChange(event) {
        if(event.data === YT.PlayerState.PLAYING) { 
            audio.pause(); // CRITICAL: Force audio to stop if video plays
            state.isPlaying = true; 
            updateIcons(); 
        }
        else if (event.data === YT.PlayerState.PAUSED) { 
            state.isPlaying = false; 
            updateIcons(); 
        }
        else if (event.data === YT.PlayerState.ENDED) {
            if(!ytLooped) {
                if(state.isLoop) { ytPlayer.seekTo(0); ytPlayer.playVideo(); }
                else {
            exitFullscreenSafe(); // <--- Add this line
            playNext();
        }
            }
        }
    }
    
    function toggleYtPlay() {
        if(state.isDirectVideo) {
            const dv = document.getElementById('direct-video-player');
            if(dv.paused) dv.play(); else dv.pause();
        } else if(ytPlayer && ytPlayer.getPlayerState) {
            const state = ytPlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                ytPlayer.pauseVideo();
            } else {
                ytPlayer.playVideo();
            }
        }
        showYTControls(); 
    }

    function toggleYtMute() {
        const icon = document.querySelector('#yt-mute-btn i');
        if(state.isDirectVideo) {
            const dv = document.getElementById('direct-video-player');
            dv.muted = !dv.muted;
            icon.className = dv.muted ? 'fas fa-volume-mute' : 'fas fa-volume-up';
        } else if(ytPlayer) {
            if (ytPlayer.isMuted()) {
                ytPlayer.unMute();
                icon.className = 'fas fa-volume-up';
            } else {
                ytPlayer.mute();
                icon.className = 'fas fa-volume-mute';
            }
        }
        showYTControls();
    }
    
    async function toggleYtFull() {
    const el = document.getElementById("yt-view-container");

    if (!document.fullscreenElement) {
        // --- ENTER FULLSCREEN & LANDSCAPE ---
        try {
            // 1. Request Fullscreen
            if (el.requestFullscreen) {
                await el.requestFullscreen();
            } else if (el.webkitRequestFullscreen) { /* Safari/iOS */
                await el.webkitRequestFullscreen();
            } else if (el.msRequestFullscreen) { /* IE11 */
                await el.msRequestFullscreen();
            }

            // 2. Lock Orientation to Landscape (Android/Chrome/PWA)
            // Note: This works best on Android. iOS Safari generally ignores this 
            // and relies on the user physically turning the phone.
            if (screen.orientation && screen.orientation.lock) {
                await screen.orientation.lock("landscape").catch(e => {
                    // Fail silently if device doesn't support locking (like some desktops)
                    console.log("Landscape lock not supported on this device/browser");
                });
            }
        } catch (err) {
            console.error("Fullscreen error:", err);
        }

    } else {
        // --- EXIT FULLSCREEN & PORTRAIT ---
        try {
            // 3. Exit Fullscreen
            if (document.exitFullscreen) {
                await document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                await document.webkitExitFullscreen();
            }

            // 4. Unlock/Reset Orientation
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }
        } catch (err) {
            console.error("Exit error:", err);
        }
    }
}
// Add this to handle Hardware Back Button or Escape Key
document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
        // The user exited fullscreen, so force Portrait/Unlock
        if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
        }
    }
});
function switchVisualMode(mode) {
    // 1. Update Buttons
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    const activeBtn = mode === 'art' ? 'mode-art' : (mode === 'canvas' ? 'mode-can' : 'mode-vid');
    const btn = document.getElementById(activeBtn);
    if(btn) btn.classList.add('active');

    // 2. Remove old ratio classes
    const leftPanel = document.querySelector('.fp-left-panel');
    if(leftPanel) leftPanel.classList.remove('ratio-art', 'ratio-canvas', 'ratio-video');

    // 3. Logic for Canvas Element Movement
    const cv = document.getElementById('canvas-video');
    const imgArea = document.getElementById('fp-img-area');
    const fp = document.getElementById('full-player');
    const art = document.getElementById('fp-art');

    if (mode === 'art') {
        if(leftPanel) leftPanel.classList.add('ratio-art');
        if(state.videoMode) toggleVideoMode();

        // Move Canvas back to background (hide it)
        if(cv.parentNode !== fp) { fp.insertBefore(cv, document.getElementById('fp-bg-gradient')); }
        
        art.classList.add('active');
        art.style.opacity = '1';
        cv.style.opacity = '0';
        // Ensure image area is visible (overriding any JS hiding)
        imgArea.style.opacity = '1';

    } else if (mode === 'canvas') {
        if(leftPanel) leftPanel.classList.add('ratio-canvas'); // 9:16 Shorts Ratio
        if(state.videoMode) toggleVideoMode();

        if(cv.src && cv.src !== "") {
            // MOVE VIDEO INSIDE FRAME FOR LANDSCAPE
            imgArea.appendChild(cv);
            
            cv.style.opacity = '1';
            art.style.opacity = '0'; // Hide art
            imgArea.style.opacity = '1'; // Ensure container is visible
            cv.play().catch(e => console.log(e));
        } else {
            showToast("No Canvas available");
            switchVisualMode('art');
        }

    } else if (mode === 'video') {
        if(leftPanel) leftPanel.classList.add('ratio-video');
        
        // Move Canvas back to background
        if(cv.parentNode !== fp) { fp.insertBefore(cv, document.getElementById('fp-bg-gradient')); }

        if(!state.videoMode) toggleVideoMode();
    }
}
function exitFullscreenSafe() {
    if (document.fullscreenElement || document.webkitFullscreenElement) {
        try {
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(e => console.log(e));
            } else if (document.webkitExitFullscreen) { // Safari/iOS
                document.webkitExitFullscreen();
            }
        } catch (e) { console.log("Exit FS Error", e); }
        
        // Unlock orientation (Android)
        if (screen.orientation && screen.orientation.unlock) {
            try { screen.orientation.unlock(); } catch(e){}
        }
    }
}
// --- STRICT PORTRAIT RESET (HARD RESET) ---
window.addEventListener('resize', () => {
    // Only execute if we have returned to Portrait Mode
    if(window.innerHeight > window.innerWidth) {
        
        // 1. GET ELEMENTS
        const cv = document.getElementById('canvas-video');
        const fp = document.getElementById('full-player');
        const bg = document.getElementById('fp-bg-gradient');
        const art = document.getElementById('fp-art');
        const imgArea = document.getElementById('fp-img-area');
        const leftPanel = document.querySelector('.fp-left-panel');
        const vidContainer = document.getElementById('yt-view-container');

        // 2. DOM RESET: Move Canvas back to background layer immediately
        // In Landscape Canvas mode, we moved it inside 'imgArea'. We must move it back.
        if(cv && fp && bg && cv.parentNode !== fp) {
             fp.insertBefore(cv, bg);
        }

        // 3. CLEAR LANDSCAPE CLASSES
        // Remove 9:16 or 16:9 ratios applied in landscape
        if(leftPanel) {
            leftPanel.classList.remove('ratio-art', 'ratio-canvas', 'ratio-video');
        }

        // 4. RESET LANDSCAPE BUTTONS
        // Reset the "Art/Canvas/Video" switcher to 'Art'
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        const btnArt = document.getElementById('mode-art');
        if(btnArt) btnArt.classList.add('active');

        // 5. VISUAL HARD RESET (FORCE ART MODE)
        // Irrespective of what was happening in Landscape, show Art & BG in Portrait.
        
        if(state.videoMode) {
            // EXCEPTION: If YouTube Video is playing, keep Video Container visible
            if(vidContainer) vidContainer.classList.add('active');
            if(art) art.classList.remove('active');
            // Ensure gradient is visible for video mode
            if(bg) bg.style.opacity = '1';
            if(imgArea) imgArea.style.opacity = '1';
        } else {
            // STANDARD AUDIO MODE RESET
            
            // Show Art
            if(art) {
                art.classList.add('active');
                art.style.opacity = '1';
            }
            
            // Show Background Gradient
            if(bg) bg.style.opacity = '1';
            
            // Show Image Container
            if(imgArea) imgArea.style.opacity = '1';
            
            // Hide YouTube Container
            if(vidContainer) vidContainer.classList.remove('active');

            // HIDE CANVAS (Forget Landscape Canvas State)
            if(cv) {
                cv.style.opacity = '0';
                // Optional: Pause canvas to save battery/reset state
                // cv.pause(); 
            }
        }
    }
});
</script>
</body>
</html>